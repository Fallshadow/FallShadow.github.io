- [运动的圆](#运动的圆)
  - [一层层的小圆围绕一个点，组成“大圆”](#一层层的小圆围绕一个点组成大圆)
    - [加入时间控制](#加入时间控制)
    - [加入自发光](#加入自发光)
    - [重叠效果](#重叠效果)
    - [位置随时间偏移](#位置随时间偏移)
- [ush 和 usf](#ush-和-usf)
  - [在工程中添加自己的 .ush 文件](#在工程中添加自己的-ush-文件)
    - [建议的目录结构](#建议的目录结构)
    - [在 .ush 里写你的函数](#在-ush-里写你的函数)
    - [在 “材质蓝图” 里调用 .ush 函数（通过 Custom 节点）](#在-材质蓝图-里调用-ush-函数通过-custom-节点)
  - [改了 .ush 没生效](#改了-ush-没生效)
  - [进阶用法](#进阶用法)
- [material function](#material-function)
  - [什么时候用 Material Function？什么时候用 .ush / Custom HLSL？](#什么时候用-material-function什么时候用-ush--custom-hlsl)


# 运动的圆

## 一层层的小圆围绕一个点，组成“大圆”

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

return (result);

```

作为遮罩蒙版输出（masked 属性）

### 加入时间控制

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

return (result);

```

可以更改 angleCount 和 oneSideCount 的值

### 加入自发光

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

outEmissive = float3(sin(time), 0, 0.1);
return (result);

```

不要忘了输出节点类型需要设置

### 重叠效果

现在我们只是输出了纯色，还没有叠加效果。如果输出的颜色数值更大，就会有叠加感。

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

outEmissive = result * float3(sin(time), 0, 0.1);
return (result);

```

### 位置随时间偏移

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle) - sin(time), cos(1-angle) - sin(time));
        result += length(pos - uv) < size;
    }
}

outEmissive = result * float3(sin(time), 0, 0.1);
return (result);

```


# ush 和 usf

在 UE 里常见几种 shader 文件后缀：

- .usf（Unreal Shader File）：真正的 shader 源文件（VS/PS/CS 等入口函数一般在这里）
- .ush（Unreal Shader Header）：Shader 头文件，专门用来放：
    - 公共函数（你这种 ClipSpaceScaleInvProportional）
    - 公共宏、结构体、常量定义
    - 被 .usf 或 Custom 节点 #include 复用
你可以把 .ush 理解成 “HLSL 的 .h/.inl”，只是 UE 自己给了一个后缀。

特点：

- 不能直接编译为 shader 入口（没有 MainVS 这种主函数）
- 被别的 shader 文件（.usf 或材质 Custom 节点）#include 后，内容会被合并到最终编译的 shader 里

## 在工程中添加自己的 .ush 文件

### 建议的目录结构

在你的工程根目录下新建：

```
YourProject/
    Shaders/
        MyCommonFunctions.ush
```

###  在 .ush 里写你的函数

比如你要复用的这个函数：

```Cpp
// MyCommonFunctions.ush

float ClipSpaceScaleInvProportional(float dis, float minDis, float maxDisScale, float minDisScale)
{
    if (dis < minDis)
    {
        return minDisScale;
    }
    return maxDisScale + (minDisScale - maxDisScale) * minDis / dis;
}
```

注意几点：

- 不要写 #include Windows 风格路径
- 不需要任何 main()，就是纯函数定义
- 尽量不要在 .ush 顶层产生全局变量（除非你清楚自己在做什么）

添加完后，重启 UE 编辑器 是最稳妥的，让 Shader 编译器重新发现文件。


### 在 “材质蓝图” 里调用 .ush 函数（通过 Custom 节点）

添加一个 Custom 节点，预备好输入输出。

在 Additional Include Files 里，直接引用：

```
/Project/MyCommonFunctions.ush
```

/Project/ → 对应你工程目录下的 Shaders/ 目录；
所以 /Project/MyCommonFunctions.ush 就是 YourProject/Shaders/MyCommonFunctions.ush。

如果你把文件放在 Shaders/SubFolder/MyCommonFunctions.ush，那就写：

```
/Project/SubFolder/MyCommonFunctions.ush
```

之后 在 Custom 的 Code 填写调用代码就可以了


## 改了 .ush 没生效

- 最简单：重启编辑器。
- 在控制台（~）输入： r.ShaderDevelopmentMode 1 。然后在材质里做一点改动（比如拖一拖节点），强制触发重新编译。（材质编译，编译材质）

## 进阶用法

- 集中管理项目级 shader 工具函数
- 做条件编译 / 配置宏

```Cpp
#ifndef MYPROJECT_CLIP_SPACE_UTILS
#define MYPROJECT_CLIP_SPACE_UTILS

float ClipSpaceScaleInvProportional(...){...}

#endif
```

- 与 UE 内置 .ush 协作：UE 自带的很多 .ush 在 Engine/Shaders/Private/ 里，可以参考它们的写法。

# material function

用材质编辑器里的节点拼出来的一段可复用逻辑

使用方式：在其它材质里通过 “Material Function Call” 节点调用；

UE 在编译材质时，会把这个函数图“展开成 HLSL 代码”，由引擎自动生成。

## 什么时候用 Material Function？什么时候用 .ush / Custom HLSL？

优先用 Material Function 的情况
- 逻辑可以用节点表达（大部分数学/条件都可以）；
- 需求：让美术/设计能看得懂、能调参数；
- 想避免写 HLSL + 避免处理 include 路径、兼容性等细节；
- 不追求极限的手写优化。

需要用 .ush / Custom HLSL 的情况
- 逻辑比较复杂，不好用节点表示：
    - 自定义循环、数组访问、大段分支、位运算等；
    - 或者你从别处拷来的现成 HLSL 代码、算法；
- 需要和引擎低层数据结构打交道（自定义缓冲、结构体、特殊宏等）；
- 写的是全局 shader / 自定义渲染通道，而不是普通材质；
- 需要迁移现有 HLSL 库，或对性能要做极细致优化。
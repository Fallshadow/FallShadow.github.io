- [运动的圆](#运动的圆)
  - [一层层的小圆围绕一个点，组成“大圆”](#一层层的小圆围绕一个点组成大圆)
    - [加入时间控制](#加入时间控制)
    - [加入自发光](#加入自发光)
    - [重叠效果](#重叠效果)
    - [位置随时间偏移](#位置随时间偏移)


# 运动的圆

## 一层层的小圆围绕一个点，组成“大圆”

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

return (result);

```

作为遮罩蒙版输出（masked 属性）

### 加入时间控制

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

return (result);

```

可以更改 angleCount 和 oneSideCount 的值

### 加入自发光

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

outEmissive = float3(sin(time), 0, 0.1);
return (result);

```

不要忘了输出节点类型需要设置

### 重叠效果

现在我们只是输出了纯色，还没有叠加效果。如果输出的颜色数值更大，就会有叠加感。

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle), cos(1-angle));
        result += length(pos - uv) < size;
    }
}

outEmissive = result * float3(sin(time), 0, 0.1);
return (result);

```

### 位置随时间偏移

```Cpp

float result = 0;

for (int angleIndex = 0; angleIndex < angleCount; angleIndex++) {
    for (int oneSideIndex = 0; oneSideIndex < oneSideCount; oneSideIndex++) {
        float angle = (angleIndex / angleCount) * sin(time * 2) * (3.14 * 2);
        float2 pos  = center + (oneSideIndex / oneSideCount) * radius * float2(sin(1-angle) - sin(time), cos(1-angle) - sin(time));
        result += length(pos - uv) < size;
    }
}

outEmissive = result * float3(sin(time), 0, 0.1);
return (result);

```
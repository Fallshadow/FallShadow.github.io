# 绘制球体

```Cpp

2DCircle = length(pos - uv);

3DSphere = length(rayOrigin - sphereCenter) - sphereRadius;

```

# 光线步进

设置模型为不发光，让光线步进去发光。

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        return float3(1, 0, 0);
    }

    rayOrigin += rayStep;
}

return float3(0, 0, 0);
```

这里需要注意 变量 worldPos 使用绝对世界坐标，在 蓝图里还需要处理一下才能让它跟着物体移动。

## 原模型透明

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        return float3(1, 0, 0);
    }

    // 每一步如果没命中，就把 opacityMask 设为 1，再往前走
    opacityMask = 1;
    rayOrigin += rayStep;
}

// 整个循环都没命中，说明这条 ray 没撞到球
// 关键就在这里，撞到了球就不会执行这里了，没撞到执行到这里就可以把遮罩设置为 0
opacityMask = 0;
return float3(0, 0, 0);
```

注意要着色的设置里也要勾选遮罩

## 本质

本质上是根据相机角度执行光线步进直接绘制的像素，所以它没有网格没有点。

## 漫反射

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        return diffuse * float3(1, 0, 0);
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

这就是经典漫反射

## 方向反转

方向有问题，我们需要反转代码中最开始的光线和视线

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        return diffuse * float3(1, 0, 0);
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

## 镜面高光

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        float3 reflection = reflect(lightDir, normal);
        float3 viewDir = normalize(-worldPos - rayOrigin);
        float specular = pow(max(dot(reflection, viewDir), 0), sParam);
        return (diffuse * float3(1, 0, 0)) + (specular * float3(1, 1, 1));
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

float3 viewDir = normalize(-worldPos - rayOrigin);

注意这句，因为 rayOrigin 已经取反了，所以这个 pos 也需要取反。

sParam 就是高光系数

# 函数

ie 不允许在 custom 中使用函数。

```Cpp

float3 colorChoose(int R, int G, int B){
    return float3(R，G，B);
}

return(colorChoose(1,0,0));

```

就比如这段代码就不允许。除非放到结构体里！

```Cpp

struct coloroperations{
    float3 colorChoose(int R, int G,int B){
        return float3(R,G,B);
    }
};

coloroperations co;
return(co.colorChoose(1,0,0));

```

# 变形效果

要更改渲染好的球体效果，需要更改距离场

float dist = length(rayOrigin - sphereCenter) - sphereRadius;

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float displace = sphereCenter + (sin(rayOrigin.x * sin(time) / 3) + sin(rayOrigin.y * sin(time) / 3) + sin(rayOrigin.z * sin(time) / 3));
                                    
    float dist = length(rayOrigin - displace) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        float3 reflection = reflect(lightDir, normal);
        float3 viewDir = normalize(-worldPos - rayOrigin);
        float specular = pow(max(dot(reflection, viewDir), 0), sParam);
        return (diffuse * float3(1, 0, 0)) + (specular * float3(1, 1, 1));
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);



```

# 甜甜圈

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

struct sdfShapes
{
    float donut(float3 p, float size, float cutout){
        float2 q = float2(length(p.xz) - size, p.y);
        return length(q) - cutout;
    }
};
sdfShapes sdf;

for (int step = 0; step < steps; step++) {
    float dist = sdf.donut(rayOrigin, 50, 25);

    if (dist < 0.01) {
        float eps = 6.001;
        float3 normal = normalize(float3(
            sdf.donut(float3(rayOrigin.x + eps,rayOrigin.y,rayOrigin.z)，50，25)
            - sdf.donut(float3(rayOrigin.x - eps,rayOrigin.y, rayOrigin.z)，50，25),

            sdf.donut(float3(rayOrigin.x,rayOrigin.y + eps,rayOrigin.z),50，25)
            - sdf.donut(float3(rayOrigin.x,rayOrigin.y - eps,rayOrigin.z)，50，25),

            sdf.donut(float3(rayOrigin.x,rayOrigin.y,rayOrigin.z + eps)，50，25)
            - sdf.donut(float3(rayOrigin.x,rayOrigin.y, rayOrigin.z - eps), 50，25)
        ));

        float diffuse = max(dot(normal, lightDir), 0);
        float3 reflection = reflect(lightDir, normal);
        float3 viewDir = normalize(-worldPos - rayOrigin);
        float specular = pow(max(dot(reflection, viewDir), 0), sParam);
        return (diffuse * float3(1, 0, 0)) + (specular * float3(1, 1, 1));
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

# 光线步进纹理

```Cpp

float3 rayStep = viewDir * -1;
float4 inputTex = Texture2DSample(texObject, texObjectSampler, uv);

for (int i = 0; i < count; i++) {

    if (inputTex.r > 0.1 && inputTex.g > 0.1 && inputTex.b > 0.1) {
        return float3(i, 0, 0);
    }

    uv += rayStep * gap;

    inputTex = Texture2DSample(texObject, texObjectSampler, uv.xy);
}

return inputTex;
```

# 切换节点

- bool 2分支
- mask 4分支
- switch 单值判断的多分支开关
- 自定义节点控制

## 自定义节点控制

```Cpp
float result = (Pick == 1.0) ? In1 : 
    (Pick == 2.0) ? In2 : 
    (Pick == 3.0) ? In3 : float3(0,0,0);

return result;
```


# 打包贴图

红绿蓝多个颜色通道来存储不同信息，比如 r 存储道路标线轮廓的遮罩，是一个具体图形。 g 存储道路，也是一个具体图形。

打包贴图就是将不同信息打包到红绿蓝通道。
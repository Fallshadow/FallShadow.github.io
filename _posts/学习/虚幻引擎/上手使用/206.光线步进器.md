# 绘制球体

```Cpp

2DCircle = length(pos - uv);

3DSphere = length(rayOrigin - sphereCenter) - sphereRadius;

```

# 光线步进

设置模型为不发光，让光线步进去发光。

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        return float3(1, 0, 0);
    }

    rayOrigin += rayStep;
}

return float3(0, 0, 0);
```

这里需要注意 变量 worldPos 使用绝对世界坐标，在 蓝图里还需要处理一下才能让它跟着物体移动。

## 原模型透明

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        return float3(1, 0, 0);
    }

    // 每一步如果没命中，就把 opacityMask 设为 1，再往前走
    opacityMask = 1;
    rayOrigin += rayStep;
}

// 整个循环都没命中，说明这条 ray 没撞到球
// 关键就在这里，撞到了球就不会执行这里了，没撞到执行到这里就可以把遮罩设置为 0
opacityMask = 0;
return float3(0, 0, 0);
```

注意要着色的设置里也要勾选遮罩

## 本质

本质上是根据相机角度执行光线步进直接绘制的像素，所以它没有网格没有点。

## 漫反射

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        return diffuse * float3(1, 0, 0);
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

这就是经典漫反射

## 方向反转

方向有问题，我们需要反转代码中最开始的光线和视线

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        return diffuse * float3(1, 0, 0);
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```
# 绘制球体

```Cpp

2DCircle = length(pos - uv);

3DSphere = length(rayOrigin - sphereCenter) - sphereRadius;

```

# 光线步进

设置模型为不发光，让光线步进去发光。

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        return float3(1, 0, 0);
    }

    rayOrigin += rayStep;
}

return float3(0, 0, 0);
```

这里需要注意 变量 worldPos 使用绝对世界坐标，在 蓝图里还需要处理一下才能让它跟着物体移动。

## 原模型透明

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        return float3(1, 0, 0);
    }

    // 每一步如果没命中，就把 opacityMask 设为 1，再往前走
    opacityMask = 1;
    rayOrigin += rayStep;
}

// 整个循环都没命中，说明这条 ray 没撞到球
// 关键就在这里，撞到了球就不会执行这里了，没撞到执行到这里就可以把遮罩设置为 0
opacityMask = 0;
return float3(0, 0, 0);
```

注意要着色的设置里也要勾选遮罩

## 本质

本质上是根据相机角度执行光线步进直接绘制的像素，所以它没有网格没有点。

## 漫反射

```Cpp
float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        return diffuse * float3(1, 0, 0);
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

这就是经典漫反射

## 方向反转

方向有问题，我们需要反转代码中最开始的光线和视线

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        return diffuse * float3(1, 0, 0);
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

## 镜面高光

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        float3 reflection = reflect(lightDir, normal);
        float3 viewDir = normalize(-worldPos - rayOrigin);
        float specular = pow(max(dot(reflection, viewDir), 0), sParam);
        return (diffuse * float3(1, 0, 0)) + (specular * float3(1, 1, 1));
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

float3 viewDir = normalize(-worldPos - rayOrigin);

注意这句，因为 rayOrigin 已经取反了，所以这个 pos 也需要取反。

sParam 就是高光系数

# 函数

ie 不允许在 custom 中使用函数。

```Cpp

float3 colorChoose(int R, int G, int B){
    return float3(R，G，B);
}

return(colorChoose(1,0,0));

```

就比如这段代码就不允许。除非放到结构体里！

```Cpp

struct coloroperations{
    float3 colorChoose(int R, int G,int B){
        return float3(R,G,B);
    }
};

coloroperations co;
return(co.colorChoose(1,0,0));

```

# 变形效果

要更改渲染好的球体效果，需要更改距离场

float dist = length(rayOrigin - sphereCenter) - sphereRadius;

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

for (int step = 0; step < steps; step++) {
    float displace = sphereCenter + (sin(rayOrigin.x * sin(time) / 3) + sin(rayOrigin.y * sin(time) / 3) + sin(rayOrigin.z * sin(time) / 3));
                                    
    float dist = length(rayOrigin - displace) - sphereRadius;

    if (dist < 0.01) {
        float3 normal = normalize(rayOrigin - sphereCenter);
        float diffuse = max(dot(normal, lightDir), 0);
        float3 reflection = reflect(lightDir, normal);
        float3 viewDir = normalize(-worldPos - rayOrigin);
        float specular = pow(max(dot(reflection, viewDir), 0), sParam);
        return (diffuse * float3(1, 0, 0)) + (specular * float3(1, 1, 1));
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);



```

# 甜甜圈

```Cpp
float3 rayOrigin = 1 - (viewDir - worldPos);
float3 rayStep = viewDir * -1;

float3 lightDir = normalize(lightPos);

struct sdfShapes
{
    float donut(float3 p, float size, float cutout){
        float2 q = float2(length(p.xz) - size, p.y);
        return length(q) - cutout;
    }
};
sdfShapes sdf;

for (int step = 0; step < steps; step++) {
    float dist = sdf.donut(rayOrigin, 50, 25);

    if (dist < 0.01) {
        float eps = 6.001;
        float3 normal = normalize(float3(
            sdf.donut(float3(rayOrigin.x + eps,rayOrigin.y,rayOrigin.z)，50，25)
            - sdf.donut(float3(rayOrigin.x - eps,rayOrigin.y, rayOrigin.z)，50，25),

            sdf.donut(float3(rayOrigin.x,rayOrigin.y + eps,rayOrigin.z),50，25)
            - sdf.donut(float3(rayOrigin.x,rayOrigin.y - eps,rayOrigin.z)，50，25),

            sdf.donut(float3(rayOrigin.x,rayOrigin.y,rayOrigin.z + eps)，50，25)
            - sdf.donut(float3(rayOrigin.x,rayOrigin.y, rayOrigin.z - eps), 50，25)
        ));

        float diffuse = max(dot(normal, lightDir), 0);
        float3 reflection = reflect(lightDir, normal);
        float3 viewDir = normalize(-worldPos - rayOrigin);
        float specular = pow(max(dot(reflection, viewDir), 0), sParam);
        return (diffuse * float3(1, 0, 0)) + (specular * float3(1, 1, 1));
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0, 0, 0);
```

# 光线步进纹理

```Cpp

float3 rayStep = viewDir * -1;
float4 inputTex = Texture2DSample(texObject, texObjectSampler, uv);

for (int i = 0; i < count; i++) {

    if (inputTex.r > 0.1 && inputTex.g > 0.1 && inputTex.b > 0.1) {
        return float3(i, 0, 0);
    }

    uv += rayStep * gap;

    inputTex = Texture2DSample(texObject, texObjectSampler, uv.xy);
}

return inputTex;
```

# 切换节点

- bool 2分支
- mask 4分支
- switch 单值判断的多分支开关
- 自定义节点控制

## 自定义节点控制

```Cpp
float result = (Pick == 1.0) ? In1 : 
    (Pick == 2.0) ? In2 : 
    (Pick == 3.0) ? In3 : float3(0,0,0);

return result;
```


# 打包贴图

红绿蓝多个颜色通道来存储不同信息，比如 r 存储道路标线轮廓的遮罩，是一个具体图形。 g 存储道路，也是一个具体图形。

打包贴图就是将不同信息打包到红绿蓝通道。

# 纹理缩放

```Cpp
struct texDistort {
    float2 texScale(float2 uv, float2 scale){
        float2 texScale = (uv - 0.5) * scale + 0.5;
        return texScale;
    }
};

texDistort txd;

float4 color = Texture2DSample(texObject, texObjectSampler, txd.texScale(uv, uvScale));
return (color);
```

# 纹理旋转

```Cpp
struct texDistort {
    float2 texScale(float2 uv, float2 scale){
        float2 texScale = (uv - 0.5) * scale + 0.5;
        return texScale;
    }

    float2 texRotate(float2 uv, float angle){
        float2x2 rotationMatrix = float2x2(cos(angle), sin(angle),
                                            -sin(angle), cos(angle));
        return mul(uv - 0.5, rotationMatrix) + 0.5;                                    
    }
};

texDistort txd;

float4 color = Texture2DSample(texObject, texObjectSampler, txd.texScale(txd.texRotate(uv, radians(uvRotate)), uvScale));
return (color);
```

# 纹理扭曲

```Cpp
struct texDistort {
    float2 texScale(float2 uv, float2 scale){
        float2 texScale = (uv - 0.5) * scale + 0.5;
        return texScale;
    }

    float2 texRotate(float2 uv, float angle){
        float2x2 rotationMatrix = float2x2(cos(angle), sin(angle),
                                            -sin(angle), cos(angle));
        return mul(uv - 0.5, rotationMatrix) + 0.5;                                    
    }

    float2 texDistortion(float2 uv, float time, float amp, float sf, float tf, float af){
        float angle = atan2(uv.y - 0.5, uv.x - 0.5);
        float radius = length(uv - 0.5);

        float distortion = amp * sin(sf * radius + tf * time);
        float primDist = sin(af * angle) * distortion;

        return texRotate(uv, primDist);
    }
};

texDistort txd;

float4 color = Texture2DSample(texObject, texObjectSampler, txd.texDistortion(uv, time, amp, sf, tf, af));
return (color);
```

## 扭曲

float distortion = amp * sin(sf * radius + tf * time);

振幅（ amplitude ） ： 直接决定扭曲“有多厉害”。数值越大，每个像素旋转的角度越大，纹理变形越剧烈，更乱。
空间频率（随半径的变化频率） （ spatial frequency ） ： 控制从中心往外，每隔多远重复一圈“波纹 / 扭曲环”。
- 越大 ⇒ 同样半径范围内出现的“波节 / 圈数”越多 ⇒ 花纹更密、更细碎。
- 越小 ⇒ 圈数少 ⇒ 扭曲变化更平滑、整体感更强。
时间频率（动画速度） （  temporal frequency ） ： 控制扭曲图案随 time 变化的快慢。
- 越大 ⇒ 随时间相位变化越快 ⇒ 扭动速度越快。
- 越小 ⇒ 动画更慢，更柔和。

float distortion = 4 * sin(3 * radius + 2 * time);

## 叠加花瓣扭曲

float primDist = sin(af * angle) * distortion;

花瓣状扭曲， angularFreq 决定的是在角度方向上的“瓣数 / 重复次数”。

## 叠加深度

```Cpp
float3 rayStep = viewDir * -1;
float4 color;

struct texDistort {
    float2 texScale(float2 uv, float2 scale){
        float2 texScale = (uv - 0.5) * scale + 0.5;
        return texScale;
    }

    float2 texRotate(float2 uv, float angle){
        float2x2 rotationMatrix = float2x2(cos(angle), sin(angle),
                                            -sin(angle), cos(angle));
        return mul(uv - 0.5, rotationMatrix) + 0.5;                                    
    }

    float2 texDistortion(float2 uv, float time, float amp, float sf, float tf, float af){
        float angle = atan2(uv.y - 0.5, uv.x - 0.5);
        float radius = length(uv - 0.5);

        float distortion = amp * sin(sf * radius + tf * time);
        float primDist = sin(af * angle) * distortion;

        return texRotate(uv, primDist);
    }
};

texDistort txd;

for(int i = 0; i < count; i++) {
    color = Texture2DSample(texObject, texObjectSampler, txd.texDistortion(uv, time, amp, sf, tf, af));

    if (color.r > 0.1 && color.g > 0.1 && color.b > 0.1){
        return color * mColor;
    }
    else if(color.r > 0.01 && color.g > 0.01 && color.b > 0.01){
        return color * fColor;
    }

    uv += rayStep * gap;
}

return (color);
```
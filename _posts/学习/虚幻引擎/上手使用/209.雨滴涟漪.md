# 基础圆环

```Cpp

float4 result = float4(0, 0, 0, 0);
float2 pointCtr = float2(0.5, 0.5);
float2 uvOffset = uv - pointCtr;

float dist = length(uvOffset);
if (dist <= radius && dist >= (radius - thick)) {
    result = float4(1.0,1.0,1.0,1.0);
}

return result;

```

这种可以但是有一个隐式的担心，就是 radius 不能比 thick 小，所以一般圆环会引入最小半径最大半径，额外增加厚度。

```Cpp

float4 result = float4(0, 0, 0, 0);
float2 pointCtr = float2(0.5, 0.5);
float2 uvOffset = uv - pointCtr;

float dist = length(uvOffset);
if (dist <= radiusMax + ringThickness && 
    dist >= radiusMin - ringThickness)
{
    result = float4(1.0,1.0,1.0,1.0);
}

return result;

```

# 渐变

```Cpp

float4 result = float4(0, 0, 0, 0);
float2 pointCtr = float2(0.5, 0.5);
float2 uvOffset = uv - pointCtr;

float dist = length(uvOffset);
float alpha = saturate(smoothstep(radiusMin - fadeInner,
                                  radiusMin + fadeInner, dist));

if (dist <= radiusMax + ringThickness && 
    dist >= radiusMin - ringThickness)
{
    result += alpha;
}

return result;

```

smoothstep(edge0, edge1, x)

当 x ≤ edge0 时，返回 0
当 x ≥ edge1 时，返回 1
当 edge0 < x < edge1 时，从 0 平滑（S 型曲线）过渡到 1


saturate(x) 把树枝限制在 [0, 1] 之间

# 随机偏移位置

```Cpp

float4 result = float4(0, 0, 0, 0);

float2 seed = float2(123.456, 789.012);
float2 offsetRange = float2(-0.5, 0.5);

for(int i = 0; i < drops; i++)
{
    seed = frac(seed * 123.456);

    float2 randOffset = lerp(offsetRange.x, offsetRange.y, seed);
    float2 uvOffset = uv - 0.5 - randOffset;

    float dist = length(uvOffset);
    float alpha = saturate(smoothstep(radiusMin - fadeInner,
                                    radiusMin + fadeInner, dist));

    if (dist <= radiusMax + ringThickness && 
        dist >= radiusMin - ringThickness)
    {
        result += alpha;
    }
}

return result;

```

厚度都被渐变值给锁定了

# 调试时间节点预览值

Time -> DebugFloat2Value

# 随时间半径增大

```Cpp

float4 result = float4(0, 0, 0, 0);

float2 seed = float2(123.456, 789.012);
float2 offsetRange = float2(-0.5, 0.5);

for(int i = 0; i < drops; i++)
{
    seed = frac(seed * 123.456);

    float2 randOffset = lerp(offsetRange.x, offsetRange.y, seed);
    float2 uvOffset = uv - 0.5 - randOffset;

    float cycle = duration + frac(randOffset);
    float pulse = frac(time / cycle);

    float radius = radiusMin + pulse * (radiusMax - radiusMin);

    float dist = length(uvOffset);
    float alpha = saturate(smoothstep(radius - fadeInner,
                                    radius + fadeInner, dist));

    if (dist <= radius + ringThickness && 
        dist >= radius - ringThickness)
    {
        result += alpha;
    }
}

return saturate(result);

```

最后 saturate 是因为有可能两个圆环交叉处过亮

# 淡出

```Cpp

float4 result = float4(0, 0, 0, 0);

float2 seed = float2(123.456, 789.012);
float2 offsetRange = float2(-0.5, 0.5);

for(int i = 0; i < drops; i++)
{
    seed = frac(seed * 123.456);

    float2 randOffset = lerp(offsetRange.x, offsetRange.y, seed);
    float2 uvOffset = uv - 0.5 - randOffset;

    float cycle = duration + frac(randOffset);
    float pulse = frac(time / cycle);

    float radius = radiusMin + pulse * (radiusMax - radiusMin);
    float radiusLimit = radiusMin + seed.y * (radiusMax - radiusMin);
    float dist = length(uvOffset);
    float alpha = saturate(smoothstep(radius - fadeInner,
                                    radius + fadeInner, dist));

    alpha *= saturate(1 - smoothstep(radiusLimit - fadeOuter,
                                    radiusLimit + fadeOuter, dist));

    if (dist <= radius + ringThickness && 
        dist >= radius - ringThickness)
    {
        result += alpha;
    }
}

return saturate(result);

```


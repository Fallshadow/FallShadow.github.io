

# 纹理轰炸

随机旋转缩放

# 具体实现

```Cpp
float result = 0;

float2 seed = float2(123.456, 789.012);

float2 scaleRange = float2(1, 3);
float2 rotateRange = float2(0, 360);
float2 offsetRange = float2(-1, 1);

float4 palette[3] = {
    float4(1, 0, 0, 1),
    float4(0, 1, 0, 1),
    float4(0, 0, 1, 1),
};

for (int i = 0; i < splats; i++) {
    seed = frac(seed * 123.456);
    
    float randScale = lerp(scaleRange.x, scaleRange.y, seed.x);
    float randRotation = radians(lerp(rotateRange.x, rotateRange.y, seed.y));
    float2 randOffset = lerp(offsetRange.x, offsetRange.y, seed);

    float2x2 rotationMatrix = float2x2(cos(randRotation), -sin(randRotation),
                                        sin(randRotation), cos(randRotation));

    float2 uvResult = mul(rotationMatrix, (uv * randScale) + randOffset);

    float4 sampledColor = Texture2DSample(inputTex, inputTexSampler, uvResult);

    sampledColor *= palette[(i + 1) % 3];

    result += sampledColor;
}

result = pow(result, contrast);
result /= (splats/brightness);

return result;
```

## 随机数

seed

### 重载

float2 randOffset = lerp(offsetRange.x, offsetRange.y, seed);

这句话在 HLSL 中，相当于

```Cpp

float2 randOffset;
randOffset.x = lerp(offsetRange.x, offsetRange.y, seed.x);
randOffset.y = lerp(offsetRange.x, offsetRange.y, seed.y);

```


## 颜色对比度

result = pow(result, contrast); 

数值越大，颜色差距越明显

## 亮度

因为我们对 splats 数量的随机图形进行了叠加，理应对结果进行此数量的除法，不妨在此处添加亮度变量

result /= (splats/brightness);
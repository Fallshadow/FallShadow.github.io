- [UV](#uv)
  - [UV坐标的平铺](#uv坐标的平铺)
  - [以圆画圆](#以圆画圆)
- [TexCoord](#texcoord)
- [Custom](#custom)
- [画一个圆](#画一个圆)
  - [xy公式画法](#xy公式画法)
  - [R直接画法](#r直接画法)
  - [HLSL画法](#hlsl画法)
  - [边缘硬化](#边缘硬化)
  - [平铺的圆](#平铺的圆)


# UV

uv 就是 2D 纹理坐标。它将 2D 纹理贴图准确地贴到 3D 模型表面。

一般可以使用乘法节点一起缩放 uv

变量遮罩 和 变量合并  分别联合控制 uv

time 节点 制作材质动画 可以用来流动 uv

除了滚动 → (滚动字幕？)

试着找找游戏中使用流动 uv 制作的案例

## UV坐标的平铺

![alt text](UV坐标的平铺.png)

![alt text](砖块.png)

float2 tex = frac( float2( uv.x * grid.x , uv.y * grid.y ) );
if( tex.x >= dim.x || tex.y >= dim.y  )
    return(0);
return(1);

当然也可以改变大小变成瓷砖

![alt text](带颜色的.png)

![alt text](完美偏移.png)

![alt text](甚至得到栅栏网格.png)

## 以圆画圆

float result = 0;

for(int index = 0; index < sides; index++){
    float angle = 2 * 3.14 * ( index / sides);
    float2 pos = center + radius * float2(cos(angle), sin(angle));
    result += length(pos - uv) < size;
}

return(result);

![alt text](以圆画圆.png)

可以乘以时间控制圆移动

float result = 0;

for(int index = 0; index < sides; index++){
    float angle = (time) * 3.14 * ( index / sides);
    float2 pos = center + radius * float2(cos(angle), sin(angle));
    result += length(pos - uv) < size;
}

return(result);

可以向外复制扩展圆

float result = 0;

for(int index = 0; index < sides; index++){

    for(int jndex = 0; jndex < copyNum; jndex++){
        float angle = (time) * 3.14 * ( index / sides);
        float2 pos = center + radius * (jndex / copyNum) * float2(cos(angle), sin(angle));
        result += length(pos - uv) < size;
    }
}

return(result);

甚至有3D感觉的！

float result = 0;

for(int index = 0; index < sides; index++){

    for(int jndex = 0; jndex < copyNum; jndex++){
        float angle = (time) * 3.14 * ( index / sides);
        float2 pos = center + radius * (jndex / copyNum) * float2(1-cos(angle), sin(3*angle));
        result += length(pos - uv) < size;
    }
}

return(result);

# TexCoord

![alt text](TexCoord.png)

如果将结果乘以 10 ， 那数值就会变为 0 - 10，就会变亮。

![alt text](<TexCoord Mult Ten.png>)

![alt text](<TexCoord Ceil.png>)

![alt text](TexCoord降格.png)

现在我们更改 MultP 的数值就可以改变列数。

![alt text](动画效果思路.png)

![alt text](sine动画.png)

两者相减即可

![alt text](步进动画.gif)

但是发现会有不透明的过渡区域

使用步进节点，控制 0.5。

如果你想控制速度，可以控制时间也可以控制 Sine 周期。

# Custom

![alt text](上述数学部分.png)

可以使用 HLSL code 代替一些数学运算节点

# 画一个圆

## xy公式画法

![alt text](两个坐标的平方相加.png)

![alt text](圆的一部分.png)

现在我们要把这个图形移动到中心位置。

![alt text](直接减法.png)

在这之后，不可以直接 power 呐，因为 power 限定必须正数。

![alt text](自乘.png)

## R直接画法

![alt text](向量平方.png)

这样就可以通过平方大小控制圆的大小了哦

## HLSL画法

![alt text](HLSL_length.png)

## 边缘硬化

![alt text](其实就是限制数值.png)

## 平铺的圆

![alt text](Frac平铺.png)

对于输入值“X”，结果是“X 减去 X 的下限”。输出值范围从零到一，包括低端，但不包括高端。

（0.2） 为 （0.2），（-0.2）为（0.8）

> 返回 x 与其向下取整之间的差值，范围在 [0,1)
> frac(1.2) = 0.2
> frac(3.99) = 0.99
> frac(-1.2) = 0.8

![alt text](frac函数.png)

float d = length(pos-(frac(uv*gridSize)));
return d <= radius;
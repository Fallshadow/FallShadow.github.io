# GameplayMessageRouter 消息系统

GameplayMessageRouter 是一个官方推荐的轻量级事件通信系统，专门用来在项目中解耦模块间通信，取代了许多场合下的 Event Dispatchers 或 GameplayTags event system。它是游戏框架插件 “GameplayMessageRuntime” 的核心组件。

GameplayMessageRouter 属于一个叫 Gameplay Message System 的机制，提供一种 基于通道（Channel）+ 数据结构（Payload） 的发布/订阅模型。

其核心思想类似：

任意对象都可以向指定通道发布一条消息，而其它订阅该通道的对象就能接收到这条消息。

通道（Channel）通常使用 GameplayTag 来标识。

# 主要组成部分

| 组件                             | 作用                                                 |
| -------------------------------- | ---------------------------------------------------- |
| `UGameplayMessageSubsystem`      | 管理全局的消息注册与广播。你通过它来发送或监听消息。 |
| `FGameplayMessageListenerHandle` | 监听器的引用，用于取消订阅。                         |
| `FGameplayMessageListenerData`   | 订阅信息（通道、过滤条件等）。                       |
| `FGameplayMessagePayload`        | 自定义数据结构，随消息发送。                         |

# 导入

可以从 lyra 游戏项目文件的插件中直接复制 GameplayMessageRouter 文件夹。

依赖项

```Cpp

PublicDependencyModuleNames.AddRange(new string[] { 
    ...
    "GameplayMessageRuntime",
    "GameplayTags",
});

```

包含路径

```Cpp

#include "GameFramework/GameplayMessageSubsystem.h"

```

# 定义消息数据结构

定义一个结构体作为消息内容

```Cpp

// MyGameMessageData.h
#pragma once
#include "GameplayMessageTypes.h"
#include "MyGameMessageData.generated.h"


USTRUCT(BlueprintType)
struct FRunWayLightIntensityChangedMessage {
    GENERATED_BODY()

    UPROPERTY(BlueprintReadWrite)
    FString ICAO = "ZGSZ";

    UPROPERTY(BlueprintReadWrite)
    FString RunWay = "15";

    UPROPERTY(BlueprintReadWrite)
    int32 LightType = 0;

    UPROPERTY(BlueprintReadWrite)
    int32 Intensity = 0;
};

```

如果需要过滤可以再弄个 Key

```Cpp
USTRUCT()
struct FRunwayKey {
    GENERATED_BODY()

    UPROPERTY()
    FString ICAO;

    UPROPERTY()
    FString RunWay;

    UPROPERTY()
    uint32 LightType = 0;

    bool operator==(const FRunwayKey& Other) const
    {
        return ICAO == Other.ICAO
            && RunWay == Other.RunWay
            && LightType == Other.LightType;
    }
};

FORCEINLINE uint32 GetTypeHash(const FRunwayKey& Key)
{
    uint32 Hash = GetTypeHash(Key.ICAO);
    Hash = HashCombine(Hash, GetTypeHash(Key.RunWay));
    Hash = HashCombine(Hash, GetTypeHash(Key.LightType));
    return Hash;
}
```

# 发送方

```Cpp

FRunwayKey rwLightIntensityKey;
rwLightIntensityKey.ICAO = FString(icao.c_str());
rwLightIntensityKey.RunWay = FString(rw.c_str());
rwLightIntensityKey.LightType = lightType;
uint32* LastIntensityPtr = LastIntensityMap.Find(rwLightIntensityKey);
if (LastIntensityPtr && *LastIntensityPtr == intensity) {
    continue;
}
LastIntensityMap.Add(rwLightIntensityKey, intensity);

FRunWayLightIntensityChangedMessage rwLightIntensityM;
rwLightIntensityM.ICAO = rwLightIntensityKey.ICAO;
rwLightIntensityM.RunWay = rwLightIntensityKey.RunWay;
rwLightIntensityM.LightType = rwLightIntensityKey.LightType;
rwLightIntensityM.Intensity = intensity;
static const FGameplayTag rwLightIntensityChangeTag = FGameplayTag::RequestGameplayTag(TEXT("AirportLight.Intensity"));
UGameplayMessageSubsystem::Get(this).BroadcastMessage
    <FRunWayLightIntensityChangedMessage>(rwLightIntensityChangeTag, rwLightIntensityM);

```

# 接收方

```Cpp
static const FGameplayTag ChannelTag = FGameplayTag::RequestGameplayTag(TEXT("AirportLight.Intensity"));
UGameplayMessageSubsystem& MessageSubsystem = UGameplayMessageSubsystem::Get(this);
ScoreListenerHandle = MessageSubsystem.RegisterListener<FAirportLightIntensityChangedMessage>(
	ChannelTag,
	this,
	&UAirportLightControllerComponent::OnLightIntensityChanged
);

void OnLightIntensityChanged(FGameplayTag LightIntensityTag, const FAirportLightIntensityChangedMessage& MessageData);

void UAirportLightControllerComponent::OnLightIntensityChanged(FGameplayTag LightIntensityTag, const FAirportLightIntensityChangedMessage& MessageData)
{
	UE_LOG(LogTemp, Display, TEXT("LightIntensityChange %s %d"), *MessageData.RunWay, MessageData.Intensity);

}

```

# 游戏标签

[知乎高赞回答](https://zhuanlan.zhihu.com/p/28621176265)

基本就是在项目设置中搜索 tags 然后添加 new source，然后再下面管理窗口，添加新的标签，这里就可以选了，名字就是 XXX.XXX，这样就会创建了

看官方文档就行。
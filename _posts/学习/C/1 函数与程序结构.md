### 多文件编程

主要考虑在实际的程序中它们分别来自于单独编译的库。

分割虽然好，但是也要考虑定义和声明在这些文件之间共享的问题。我们要尽可能把这些文件共享的部分集中起来放到一起，这样就只需要一个副本，改进程序时也容易保证程序的正确性。

## 静态修饰

静态外部变量：在外部变量前面加上 static 来隐藏它们，其作用域为被编译源文件的剩余部分。

静态内部变量：在内部变量前面加上 static 来隐藏它们，其作用域为当前函数。
这样定义的内部变量会一直持有存储空间，而不像普通的自动变量那样随着函数调用和结束而分配和释放。

静态变量的生命周期与程序的生命周期相同，它们只会在程序结束时才会被释放。当程序结束时，操作系统会回收程序使用的所有内存，包括静态变量存储的内存。
需要注意的是，如果静态变量是指针类型，它所指向的内存可能需要手动释放。例如，如果静态变量是一个指向动态分配内存的指针，那么在程序结束时需要调用 free 函数手动释放内存。
另外，如果静态变量是在函数内部定义的，那么它的生命周期仍然是整个程序的生命周期，但是它的作用域仅限于该函数内部。当函数返回时，该静态变量仍然存在，但是它不能被其他函数访问。

静态函数：在函数前面加上 static 来隐藏它们，其作用域为被编译源文件。

## 寄存器变量

使用 register 声明的变量，仅仅适用于自动变量或者函数的形式参数，其目的在于加快存在高频变量的函数的速度。

原理：使用 register 声明的变量会告知编译器将自己放在寄存器中，以便于快速访问。

实际情况：

*   寄存器变量无法访问，因为它是没有地址值的。
*   寄存器变量的值无法被取出使用，因为它的值放在寄存器中，而不是内存中。
*   编译器不一定会真的把其放在寄存器中，编译器会忽略过量的或者不支持的寄存器变量。（具体根据机器而异）

下面是一个使用寄存器变量的例子：

```C
#include <stdio.h>

int main() 
{
    register int i = 0; // 声明寄存器变量
    int sum = 0;
    for (i = 1; i <= 10000; i++) 
    {
        sum += i;
    }
    printf("sum = %d\n", sum);
    return 0;
}
```

在上面的例子中，声明了一个名为 i 的寄存器变量，然后在 for 循环中使用它计算 1 到 10000 的和。由于 i 是寄存器变量，因此计算速度会比普通变量快一些。

## 程序块结构

C 不允许在函数中定义函数，但是可以在函数中以程序块结构定义变量，程序块里面定义的变量与程序块外面的同名变量完全无关。

```C
int main() 
{
    int var1 = 1;
    {
        int var1 = 2;
        printf("%d\n", var1);
    }
    printf("%d", var1);
}
```

在上面的例子中，在程序块内声明定义了一个与外面同名的 var1，这段程序输出 2\n1,。

一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名称的情况。

## 初始化

对于静态变量和外部变量，在程序开始执行前就初始化，并且初始化表达式必须是常量表达式。
对于自动变量和寄存器变量，则在每次进入函数或程序块时初始化，初始化表达式不一定是常量表达式。

字符数组初始化比较特殊，可以使用字符串来进行初始化。

    char pattern[] = "ould";
    char pattern[] = {'o','u','l','d','\n'};

上述例子里两个初始化等价，字符串结尾有一个、n。

## C 预处理器

#### 文件包含

任何形如#include<文件名>或者#include"文件名"的行都将替换为文件名指定文件的内容。
如果文件名使用引号引起来，则在源文件位置查找该文件，这个规则同具体的实现有关。被包含的文件本身也可包含#include 指令。
如果某个包含文件的内容发生变化，所有依赖于该包含文件的源文件都需要重新编译。

#### 宏替换

\#define 名字 替换文本
所有此名字的地方都会被替换为替换文本。

*   替换文本也可以换行，在行末使用一个反斜杠、\
*   可以带参数，类似函数一样使用宏

```C
#define min(a,b) a > b ? b : a

int main() 
{
    int a = 1, b = 2, c = 3, d = 4;
    int e = min(a + b, c + d); // 等同于 a + b > c + d ? a + b : c + d
    printf("%d", e);
}
```

上述例子中你会发现一些缺点，宏定义参数 a 和 b 会被计算两次，如果 a 和 b 本身替代的是表达式的话，会产生意想不到的效果：

```C
#define min(a,b) a > b ? b : a

int main() 
{
    int a = 1, b = 2 ;
    int e = min(a++, b++);
    printf("%d\n", e);  // 2
    printf("%d\n", a);  // 3
    printf("%d\n", b);  // 3
}
```

其次还应该考虑使用括号防止一些意想不到的情况

```C
#define square(x) x * x

int main() 
{
    int a = 1, b = 2;
    int e = square(a + b);  // 5
    printf("%d\n", e);
}
```

getchar 和 putchar 函数常常使用宏来避免处理字符时调用函数所需的运行时开销。这句话的意思是，getchar 和 putchar 函数通常使用宏来实现，而不是使用函数调用。使用宏可以避免在运行时调用函数所需的开销，因为宏是在编译时展开的，而不是在运行时执行的。这意味着在处理字符时，使用宏可以更快地执行，因为它们不需要在每次调用时执行函数调用的额外开销。

可以通过#undef 名字 指令来取消名字的宏定义，这样做可以保证后续使用的是其他调用，而不是宏调用。

宏调用的形式参数不能够替换后续替换字符中的引号里的内容，但是可以使用#名字来进行替换。

```C
#define log(x) printf(#x "= %d",x)

int main() 
{
    int a = 1, b = 2;
    log(a + b);
}
```

#### 条件包含

可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行过程中进行计算，这种方法为在编译过程中根据计算所得条件值选择性地包含不同代码提供了一种手段。
\#ifdef #ifndef

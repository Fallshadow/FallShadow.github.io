- [C#](#c)
  - [内存管理](#内存管理)
  - [C#基类及其值类型引用类型](#c基类及其值类型引用类型)
  - [结构体为何不可继承](#结构体为何不可继承)
  - [Int 强转 String 会触发装箱么](#int-强转-string-会触发装箱么)
  - [Struct 内存对齐规则](#struct-内存对齐规则)
  - [使用 NEW 申请堆上内存底层实现过程](#使用-new-申请堆上内存底层实现过程)
  - [struct 什么情况下会产生装箱](#struct-什么情况下会产生装箱)
  - [静态构造函数](#静态构造函数)
  - [构造函数子类和基类的调用顺序](#构造函数子类和基类的调用顺序)
  - [foreach 具体实现](#foreach-具体实现)
  - [Dictionary 原理](#dictionary-原理)
- [C++](#c-1)
  - [指针是什么？指针和引用区别？](#指针是什么指针和引用区别)
  - [宏定义的本质](#宏定义的本质)
    - [pragma once](#pragma-once)
  - [Map](#map)
- [Unity](#unity)
  - [协程和线程](#协程和线程)
  - [Mono 和 il2cpp 的区别](#mono-和-il2cpp-的区别)
  - [UI 的优化点](#ui-的优化点)
  - [BUFF 系统](#buff-系统)
  - [行为树庞大如何优化](#行为树庞大如何优化)
  - [Timeline](#timeline)
  - [DotsJobSystemBrust](#dotsjobsystembrust)
  - [UIMVP](#uimvp)
  - [NavMesh](#navmesh)
  - [Dictionary 序列化](#dictionary-序列化)
- [游戏开发理解](#游戏开发理解)
  - [CPU 架构](#cpu-架构)
  - [GPU 架构](#gpu-架构)
  - [手机游戏发烫的原因](#手机游戏发烫的原因)
  - [浮点数和物理定点数](#浮点数和物理定点数)
  - [entt 如何快速筛选拥有多个组件的实体](#entt-如何快速筛选拥有多个组件的实体)
  - [碰撞检测](#碰撞检测)
  - [物理休眠和物理穿透和物理确定性](#物理休眠和物理穿透和物理确定性)
- [渲染](#渲染)
  - [凸多边形求交和凸多面体求交](#凸多边形求交和凸多面体求交)
  - [OpenGL 渲染流程](#opengl-渲染流程)
  - [渲染阶段](#渲染阶段)
  - [帧缓冲](#帧缓冲)
  - [混合](#混合)
  - [点乘叉乘应用](#点乘叉乘应用)
  - [万向节](#万向节)
  - [四元数](#四元数)
  - [遮挡剔除](#遮挡剔除)
  - [光的挑战阴影和 GI](#光的挑战阴影和-gi)
  - [物理材质](#物理材质)
  - [地形](#地形)
  - [环境遮挡 AO](#环境遮挡-ao)
  - [抗锯齿 AA](#抗锯齿-aa)
  - [后处理](#后处理)
  - [历史渲染管线](#历史渲染管线)
  - [屏幕撕裂](#屏幕撕裂)
  - [光照](#光照)
- [7.30](#730)
- [厦门勇仕](#厦门勇仕)

# C#
## 内存管理
垃圾回收器（GC）
GC 是 .NET 提供的一种自动内存管理机制。它负责在对象不再被使用时释放这些对象占用的内存。以下是 GC 的一些特点和工作原理：
标记阶段：GC 找出所有的活动对象（即仍被引用的对象）。
清理阶段：将不再使用的对象标记为垃圾，并释放这些对象占用的内存。
压缩阶段：可选步骤，将活动对象移动到内存的另一块区域，以便减少内存碎片现象。
代（Generations）
GC 使用代的概念将对象分类：
代 0：新创建且存活时间较短的对象。GC 常频繁回收代 0。
代 1：经历过至少一次回收且仍存活的对象。
代 2：持久性较强，生命周期较长的对象。
这种代际策略旨在优化 GC 的效率，因为大多数对象都是短期存活的，频繁回收这些对象提升了回收的效率。

避免长时间持有对不必要对象的引用。
谨慎使用静态字段和全局对象
及时解除事件订阅
不重要缓存可以使用 WeakReference（使用时需要先询问）
## C#基类及其值类型引用类型
C#语言中的所有类型都是由基类 System.Object 继承过来的，包括最常用的基础类型：int, byte, short，bool 等等，就是说所有的事物都是对象。如果申明这些类型得时候都在堆 (HEAP) 中分配内存，会造成极低的效率！
.NET 如何解决这个问题得了？正是通过将类型分成值型 (value) 和引用型 (regerencetype)，C#中定义的值类型包括原类型（Sbyte、Byte、Short、Ushort、Int、Uint、Long、Ulong、Char、Float、Double、Bool、Decimal）、枚举 (enum)、结构 (struct)，引用类型包括：类、数组、接口、委托、字符串等。
值型就是在栈中分配内存，在申明的同时就初始化，以确保数据不为 NULL；引用型是在堆中分配内存，初始化为 null

## 结构体为何不可继承
关于为何结构体不可继承，其中一个重要的原因是由于结构体所代表的值类型需要直接分配到栈上，在入栈出栈的时候必须能够确定其数据大小，因此结构体需要提供明确固定的大小。如果允许继承，下面这种情况是难以预测的：
S1：S2
S1 A；
S2 B = A；
## Int 强转 String 会触发装箱么
ToString() Convert.ToString(int) 和 String.Format(int) 方法都不会触发装箱。
方法会创建一个新的 string 对象，是一个直接的过程
将 string 转换为 int 时，使用的是解析方法（如 int.Parse()）或转换方法，这个过程也同样直接，不涉及装箱或拆箱。
装箱发生在将一个值类型（例如 int）赋值给一个 object 类型的变量时。
拆箱发生在将一个存储为 object 的值类型提取出来时。

## Struct 内存对齐规则

对于结构体的各个成员，除了第一个成员的偏移量为 0 外，其余成员的偏移量是 其实际长度 的整数倍，如果不是，则在前一个成员后面补充字节。

结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。

如程序中有  #pragma pack(n) 预编译指令，则所有成员对齐以 n 字节 为准（即偏移量是 n 的整数倍），不再考虑当前类型以及最大结构体内类型。

举例说明 char short int double 分别占用 1，2，4，8 字节。下面是几种排列对应的内存占用。
1248，1 在第一位，偏移为 0，2 长度为 2，偏移为最小整数倍的 2，所以是 2，内存中 1 号就被空出来了，4 同理 8 也同理。

## 使用 NEW 申请堆上内存底层实现过程
当你使用 new 关键字创建一个对象时
内存分配：程序会在堆上请求足够多的内存来存储类型的实例。
构造函数调用：分配到的内存随后会被初始化，并调用构造函数。此时，构造函数的代码会在堆上进行执行，来设置实例的初始状态。
返回引用：最后，new 表达式会返回一个对该新分配的内存块的引用，并将其赋值给 obj。

在低层次的实现中，内存管理通常由 .NET CLR (Common Language Runtime) 的内存管理器负责。内存分配和释放的实际细节由 CLR 和底层的操作系统共同处理，这里是一些关键点
内存分配：当 CLR 需要在堆上分配内存时，它会调用操作系统的 API（如 VirtualAlloc）来请求一定大小的内存块。档次内存分配时，CLR 会从一个内存池中分配内存，使用更高效的分配策略来快速满足内存申请。
内存管理：分配后，内存可能会被标记为可用或占用，CLR 会维护一张分配记录，以跟踪有哪些内存是被使用的。
垃圾回收：当对象不再被使用时，CLR 的垃圾收集器会定期运行，自动检测不再被引用的对象并释放其占用的内存。这有助于防止内存泄漏。

## struct 什么情况下会产生装箱
赋值给 object 类型；
在非泛型集合类中（如 ArrayList 和 Hashtable），当您将结构体添加到集合中时，会发生装箱；
当结构体实现一个接口并在该接口类型的变量中使用时，如果将结构体实例分配给接口变量，也会发生装箱；
当结构体作为参数传递给一个接受 object 类型参数的方法时，会发生装箱。
如果结构体的一个实例作为一个返回值，而调用这个返回值的函数期望接收一个 object 类型，也会发生装箱。
如何避免？
使用泛型类和泛型方法，这样可以避免使用 object 类型并因此避免装箱。
在设计时避免将结构体用作接口的实现，或者将它们放在需要引用类型的集合中。
## 静态构造函数
静态构造函数是用来初始化静态成员的构造函数。静态构造函数是在类被加载时自动调用的构造函数。它通常用于初始化静态字段或执行其他初始化任务。
静态构造函数没有参数，并且没有访问修饰符
自动调用： 静态构造函数在类第一次访问或创建时自动执行（例如，当你第一次调用类的静态成员或创建其实例时）。
只调用一次： 不管你实例化多少次该类，静态构造函数只会被调用一次。
不能手动调用： 你无法直接调用静态构造函数，它会在类被加载时自动执行。
不能有参数： 静态构造函数不能接受参数。
线程安全： .NET Framework 确保静态构造函数是线程安全的，即使在多个线程同时访问类时。
如果类没有静态构造函数，C# 会为你提供一个默认的静态构造函数。
## 构造函数子类和基类的调用顺序
在初始化一个子类实例之前，基类构造函数会首先执行。这保证了所有基类的成员在使用子类之前就已经被正确初始化。
如果子类没有明确调用基类的构造函数，C# 将自动调用基类的无参构造函数（如果存在）。
你可以在子类构造函数中使用 base 关键字显式调用基类的构造函数。以此可以调用带参数的基类构造函数而非默认的无参构造。
## foreach 具体实现
要使自定义类支持 foreach 循环，需要实现 IEnumerable 和 IEnumerator 接口。
IEnumerable 接口用于提供一个迭代器（即 GetEnumerator 方法），而 IEnumerator 接口则用于控制迭代过程。

```Cpp
using System;  
using System.Collections;  
using System.Collections.Generic;  

public class MyCollection : IEnumerable<string>  
{  
    private List<string> items = new List<string>();  
    public void Add(string item)  
    {  
        items.Add(item);  
}  

    // 实现 IEnumerable 接口  
    public IEnumerator<string> GetEnumerator()  
    {  
        return new MyEnumerator(items);  
}  

    // 实现非泛型 IEnumerable 接口  
    IEnumerator IEnumerable.GetEnumerator()  
    {  
        return GetEnumerator();  
    }  

    // 自定义的迭代器类  
    private class MyEnumerator : IEnumerator<string>  
    {  
        private List<string> _items;  
        private int _position = -1;  

        public MyEnumerator(List<string> items)  
        {  
            _items = items;  
        }  

        public string Current => _items[_position];  

        object IEnumerator.Current => Current; // 非泛型当前元素  

        public bool MoveNext()  
        {  
            _position++;  
            return (_position < _items.Count);  
        }  

        public void Reset()  
        {  
            _position = -1;  
        }  

        public void Dispose() { } // 这里没有资源需要释放  
    }  
}  

// 使用示例  
class Program  
{  
    static void Main()  
    {  
        MyCollection collection = new MyCollection();  
        collection.Add("item1");  
        collection.Add("item2");  
        collection.Add("item3");  

        // 使用 foreach 遍历  
        foreach (var item in collection)  
        {  
            Console.WriteLine(item);  
        }  
    }  
}  
```

## Dictionary 原理
哈希表来实现，将键转换为一个哈希值，哈希值进一步取模的到哈希桶的索引。如果发生哈希碰撞，可以使用二次探查，双重哈希等处理，也可以让哈希桶储存一个链表，发生碰撞后，放到链表的末尾。哈希表还有一个负载因子，在总体容量达到负载因子，比如 75%的时候，进行扩容，增加存储桶的数量并重新映射现有键值对。

# C++ 
## 指针是什么？指针和引用区别？
指针本质上就是一个整数，指向内存地址。
引用是对指针的一个语法糖，让代码更简洁。

## 宏定义的本质

预处理器指令：宏定义在编译期间的预处理阶段被处理。预处理器扫描源代码，识别 #define 指令并替换相应的代码段。

文本替换：在编译器实际编译代码之前，宏会进行文本替换。这种替换是全局的，并且不是按作用域绑定的。

没有作用域：宏定义没有作用域的概念。这意味着宏的定义在整个文件中有效，前面定义的宏可能会被后面重新定义，从而导致潜在的名称冲突。

### pragma once

```C++
#pragma once // 确保该文件在一个编译单元中只被包含一次
```

## Map
Std::Map 底层红黑树

# Unity
## 协程和线程
协程是通过协作方式实现的轻量级线程，是一种用户级线程，它能够在执行过程中挂起和恢复，并在 Unity 的主线程中运行，适合于需要等候和时间控制的操作。等待输入、延迟等，而不会阻塞主线程。它通过 yield 关键字来暂停执行，并且在下一帧或特定条件下继续执行。必须使用 StartCoroutine 来启动协程，通常与 Unity 的生命周期紧密相连。

线程是真正的操作系统级别的并发执行单元，由操作系统调度和管理。用于处理更重的计算任务，在多个核心上并行地执行。可以在后台执行，不受 Unity 的主线程限制。这意味着线程可以在不影响主线程性能的情况下执行复杂的计算。

协程不是线程，但在某些方面可以实现类似的功能，具体的使用场景和需求决定了选择使用何种方法。

## Mono 和 il2cpp 的区别

首先简单介绍下，JIT 和 AOT 这两种代码编译和执行的策略。

JIT 就是 just in time

    1：即时编译：在程序运行过程中仅仅将需要的部分代码编译为本机代码，即编译发生在代码即将执行的时候。

    2：延迟编译：只有被调用的代码才会被编译，未使用的代码不会被编译，潜在地减少了初始的编译量。

    3：启动速度慢：前两个特点注定了这个特点，第一次运行时，会有大量代码等待即时编译。

    4：内存占用：JIT 实时编译的代码驻留在内存中，增加内存占用。

    5：二进制文件大小：由于生成的是独立于平台的中间语言，在不同平台通过相应的运行时环境解释编译，生成的二进制文件较小。

AOT 就是 ahead of time

    1：提前编译：在应用运行前所有的代码都被编译为本机代码。

    2：预知编译：处理所有可能的代码路径和类型，包含所有必要的代码

    3：启动速度快。

    4：运行时性能稳定：因为没有运行时编译开销，性能表现更加稳定。

    5：二进制文件大小：编译生成的二进制文件主要包含已经编译好的、本机可执行的特定于平台的代码，通常较大。

Mono  JIT  启动速度慢，内存占用越来越大（虽然本身也有优化）

IL2CPP  AOT 启动更快速，性能稳定，内存占用更小

## UI 的优化点
尽量避免/减轻 Canvas 的重绘：
1：动静分离：将频繁改变的，和基本不变的分离成两个不同的 Canvas
2：减少小元素对大范围的影响
尽量利用合批：
1：减少 UI 元素的嵌套层级，以减少重绘成本。
2：多个小图像打包成大图集，减少 draw call 数量。
合理使用布局组：
Layout Group 和 Content Size Fitter 会导致重建，影响性能。
1：在不影响使用的前提下，尽量使用固定布局而不是自动布局
减少透明度变化：
1：能用隐藏和显示代替的逻辑，不要使用透明度控制
（- 1：透明度从后向前排序可能增加 Draw Call ）
（- 2：透明度混合增加复杂性）
UI 对象：
1：对象池管理小对象。尽量减少删除和创建，对于多项条目，无尽列表很有用。
2：延迟卸载功能界面
字体：
1：能用静态字代替，就不要动态绘制

## BUFF 系统
载体创建
替换规则，表格查验
挂载请求（主要是查验免疫 BUFF 的执行者）
配合载体进行状态检验（角色/怪物/宠物死亡状态？无敌霸体状态免疫 debuff？）
冷却
冲突规则（来源/ID/组 互斥替换叠加独立叠加刷新   替换独立互斥）

- 直接挂载（buff 工厂，发送挂载消息，创建流程，挂载触发，叠层，buff 更新）
- 替换挂载
- 叠加挂载
- 叠加刷新挂载

由外界消息触发或者自身检测触发，以进入触发流程
载体状态检测
触发器自身参数条件检测
生效：概率生效判定，satisfy 满足触发生效条件，satisfy 不满足触发生效条件
表现 OnEffect

Buff 系统的 tick

## 行为树庞大如何优化
根据状态模块化，比如巡逻状态，战斗状态

## Timeline
自定义轨道，自定义混合行为
PlayableBehaviour，PlayableAsset，TrackAsset。
MixerBehaviour
信号接收器

## DotsJobSystemBrust
NativeArray 数据
Brust 编译包 通过将高级 C#代码转换为高度优化的机器码，显著提高了性能。
在 Job 结构体上添加 [BurstCompile] 属性以开启 Brust 编译
IJobParallelFor  支持并行循环优化，通过并行处理数组或列表中的数据来提高性能
单个调度，并行调度，依赖关系调度（handle）
JobHandle handle = myJob.Schedule(); 
JobHandle handle = myParallelForJob.Schedule(arrayLength, batchSize);  
JobHandle handle = myParallelForJob.Schedule(arrayLength, batchSize, previousJobHandle);  
总任务、每个线程每次处理的任务数量、依赖项

## UIMVP
Model 只管业务，View 只管 UI，P 负责协调两者。
就比如之前制作的邮件系统，就算没有 UI，也一样可以接收邮件，存储邮件。这个主要是解耦，让 MP 就可以进行测试。

## NavMesh
使用 NavMeshObstacle 组件来处理动态障碍。
使用 NavMeshSurface 组件来重新烘焙整个 NavMesh。
使用 NavMeshBuilder.UpdateNavMeshDataAsync 来局部更新 NavMesh。

## Dictionary 序列化
Unity 中，字典（Dictionary<TKey, TValue>）并不直接支持序列化通过自定义类或实现 ISerializationCallbackReceiver 接口来间接实现
创建一个可序列化的类，用于保存字典的键值对。可以使用列表（List<T>）来替代字典的结构。
如果您需要更多的控制，可以实现 ISerializationCallbackReceiver 接口。这个接口允许您在序列化和反序列化时进行自定义操作

# 游戏开发理解
## CPU 架构
指令集、微架构、缓存、流水线    执行单元，寄存器，总线，缓存，内存

指令集架构定义了 CPU 可以执行的所有指令和操作码。
CISC：指令集合复杂，每条指令可以执行多种操作。（x86 架构）在复杂计算和多功能处理上表现出色。
RISC：指令集合简化，指令执行速度更快，通常每条指令只做一件事。（ARM 架构、RISC-V 架构）简单且高度优化的指令集。主要优势是能效高、发热量低。

微架构是指 CPU 内部实现指令集的一种具体设计，包括流水线、执行单元、缓存等。不同的微架构在同一个指令集架构下可以有不同的性能和功耗表现。
流水线（Pipeline）：将指令执行过程分割成多个阶段，每个阶段并行处理不同的指令，提高吞吐量
分支预测：一种提高指令流水线效率的技术，通过预测程序中分支指令（如条件跳转）的执行路径，减少流水线		    的停顿。
静态分支预测：基于固定模式的预测，如总是预测分支会跳转或不会跳转。
动态分支预测：基于历史记录和统计模型进行预测，准确性更高。
超标量：一种扩展的流水线技术，允许多个指令在一个时钟周期内并行执行。通过多个执行单元实现多指令并行处理。
SMT（超线程技术）：允许一个 CPU 核心在同一个时钟周期内同时处理多个线程，提高 CPU 资源利用率。

缓存是位于 CPU 和主内存之间的小而快速的存储，用于减少 CPU 访问内存时的延迟。L1,2,3

内存管理单元 (Memory Management Unit，MMU)：MMU 是处理虚拟内存地址到物理内存地址转换的硬件单元。它管理内存保护和地址转换，提高内存访问的安全性和效率。
页表：MMU 维护页表来管理虚拟地址与物理地址的映射
TLB：一种快速缓存，用于存储最近使用的页表项，减少地址转换时间

## GPU 架构
一种专门用于图形计算和并行处理的大规模数据处理的硬件。
1：流处理器（Streaming Multiprocessor，SM）
流处理器是 GPU 的基本计算单元，每个流处理器包含多个核心。
并行处理大量的数据，可以同时执行多条指令，适合大规模并行计算任务。

核心（Cores）：基本的计算单元，执行基本的数学运算，如加减乘除。
寄存器文件（Register File）：用于存储临时数据和指令操作数。
调度单元（Scheduler）：管理和调度核心的工作。

2：并行计算单元（Parallel Processing Units，PPUs）
GPU 由多个 PPU 组成，每个 PPU 包含若干个流处理器。
实现大规模并行计算，大幅提高计算效率。

3：CUDA 核心和 Tensor 核心
CUDA 核心：CUDA 核心是流处理器的一种，实现基本浮点和整数运算。适用于图形渲染、物理仿真和图像处理等任务。
Tensor 核心：Tensor 核心是专门为深度学习设计的硬件加速单元，能够高效处理矩阵乘法等操作。大幅提高神经网络训练和推理的速度。

4：纹理单元（Texture Units）
功能：负责处理纹理映射和纹理过滤，将 2D 图像和 3D 模型结合在一起。具有高效的缓存机制和硬件加速功能，优化图形渲染性能。

5：内存架构
全局内存（Global Memory）：全局内存是 GPU 上容量最大但速度相对较慢的存储。所有流处理器都可以访问，共享数据。
共享内存（Shared Memory）：每个流处理器内部的共享内存，访问速度快。用于线程之间的数据交换和协作计算。
寄存器（Registers）：每个核心专属的高速存储，用于存储临时数据。访问速度最快，但数量有限。
常量内存（Constant Memory）：只读缓存，用于存储不变的数据，如程序参数。很高的访问速度，但容量小。
纹理内存（Texture Memory）：专用于存储纹理数据，具有专用硬件加速访问。

图形渲染管线：包括顶点处理、图元组装、光栅化、片段处理和最终帧缓冲等阶段。每个阶段都有专门的硬件单元进行加速处理。

## 手机游戏发烫的原因
帧率，分辨率，亮度，图形设置，动态资源加载，多线程处理任务。

## 浮点数和物理定点数
符号位，指数位，尾数
定点数表示方法是一种数值存储方式，其中数值的小数部分和整数部分的位数是固定的。这与浮点数不同，浮点数的小数部分和指数部分的位数是动态的。需要计算的
定点数可以理解为简单的移位，所以 32 位浮点数其实远远大于 64 位定点数。64 位定点数仅仅是高 32 位储存整数，低 32 位储存小数罢了。

## entt 如何快速筛选拥有多个组件的实体
entt 库中如何筛选拥有多个组件的实体，有接口么，具体实现是什么？
EnTT 如何快速搜索同时包含 3 个组件的实体？底层是什么？稀疏集是什么？
EnTT 利用了数据局部性和稀疏集（SparseSet）数据结构：

实体数组 [E1,E2,NULL,E4]
组件 A 内存管理
密集的，数据局部性的数组 A[C1，C4]
与实体数组相同的固定大小的稀疏数组 A[->C1,NULL,NULL,->C4] 其索引就是实体 ID

组件 B 内存管理
密集的，数据局部性的数组 B[B2，B4]
与实体数组相同的固定大小的稀疏数组 A[NULL,->B2,NULL,->B4] 其索引就是实体 ID

至于同时搜寻具有 AB 的，稀疏数组有一个对应的位图，方便去选出。

## 碰撞检测
粗筛阶段：
BVH （bounding volume hierarchy）层次包围盒：更新成本低，适合动态场景
Sort And Sweep 排序扫描：先排序再逐个扫描，效率高，更符合大部分为静态物体小部分为动态物体的现实。更好

细筛阶段：用精细碰撞再次检测，然后找到碰撞点。
    对于简单几何，可以简单获取碰撞点、碰撞深度、碰撞法线，但是不规则凸包就有些麻烦，有两种算法：
        Minkowski：闵可夫斯基加减法
            两个凸包用减法求集合，然后判断集合包不包含原点就可以得出结论。包含即重叠了，否则没碰上。这里求解可以用 GJK 算法（寻找对冲极端点的求减三角形）。两个思想：闵可夫斯基把凸包求交的问题转化为集合过圆心的问题；GJK 沿着趋势最快去逼近的优化思想。
        分离轴定理：Separating Axis Theorem (SAT)：对于一个在二维空间上的不相交的凸多面，一定可以找到一个轴，这两个凸多面在这根轴上的投影不相交；
            更近一步！一定可以找到其中一个凸多面的一个边，其延长线完全分离这两个凸多面；放到三维的话，除了要找到其中一个凸多面体的一个面之外还要看看是不是有 A 中一边和 B 中一边的叉乘面满足完全分离。（小细节，下一次算的时候，可以用上一次算出来的分离轴作为起始，毕竟我们模拟的游戏世界没有那么快速变化）

## 物理休眠和物理穿透和物理确定性
一般物理引擎计算时间也就 2、3ms，所以物理引擎会把物体分成很多 Island，在没有力输入的情况下，这些 Island 都在睡眠。
CCD（Continuous Collision Detection）：持续碰撞检测。
    隧穿效应 XDDD，如果出现这种了，就有问题。
确定性问题：两次运行我们的游戏，每次都是一样的输入，结果会一样的么？如何保证一样？（比如服务器的物理碰撞和客户端物理碰撞，确定性物理引擎 + 帧同步 就会绝对正确）
    相同的物理模拟顺序
    确定性模拟求解序列
    浮点数一致性

# 渲染

## 凸多边形求交和凸多面体求交

先判断多边形是 CCW = Counter-Clockwise = 逆时针 还是 CW = Clockwise = 顺时针。点是逆时针排序，多边形的内部始终说的是左边。点是顺时针排序，多边形的内部始终说的是右边。（注意这里所谓的判断顶点 p 是否在裁剪边内侧，指的就是 CCW CW 那个判定）

    设定裁剪边：取出多边形 B 的当前边，这条边由顶点对 (clip_start,clip_end) 定义。
        初始化输入顶点列表：
        遍历输入顶点：设 input_polygon 为被裁剪多边形的顶点序列。令 s 为 input_polygon 的最后一个顶点（形成首尾相接的环）。output_polygon 为输出的多边形顶点序列。
            遍历 input_polygon 中的每个顶点 p：
                判断顶点 p 是否在裁剪边内侧：
                    顶点在内侧：
                        如果 p 在裁剪边的内侧（或边上），则进一步检查顶点 s：
                        如果顶点 s 在裁剪边的外侧，则计算并添加 s 和 p 之间的交点到 output_polygon。
                        无论如何， p 都应该添加到 output_polygon。（因为相交了）
                    顶点在外侧：
                        如果 p 在裁剪边的外侧，则进一步检查顶点 s：
                        如果顶点 s 在裁剪边的内侧，则计算并添加 s 和 p 之间的交点。
                        s 在外侧则什么也不加
                每轮结束后，将 s 更新为当前的 p
    处理完一条裁剪边
        当前得到的 output_polygon 就是针对这条边裁剪后的结果，下一条裁剪边时，将它作为新的 input_polygon。



逐面裁剪：遍历多面体 B 的每一个面，对多面体 A 进行裁剪：
设定裁剪面：当前裁剪面由多面体 B 的一种面定义，这个面可以由一个顶点列表或边列表来表示，并且有法向量。
遍历每一个面：初始化 input_vertices，对于每个面中的每个边（顶点对），判断是否有部分或全部在裁剪面内侧：
            顶点在内侧：保留这个顶点。
            顶点在外侧：舍弃这个顶点。
            边跨越面：计算并添加交点。
        将新的顶点和交点更新至 output_vertices，更新面的定义至 output_faces。
    重复此过程，直到多面体 B 的所有面都用于裁剪多面体 A。

## OpenGL 渲染流程

绘制顶点：申请缓冲区 VBO，绑定缓冲区 VBO，绑定数据 V
解释顶点：申请缓冲区 VAO，绑定缓冲区 VAO，依次定义顶点属性
（已经可以绘制，使用 DrawArray)
索引优化：申请缓冲区 IBO，绑定缓冲区 IBO，绑定数据 I
（利用索引绘制，使用 DrawElement)

申请纹理对象空间，绑定纹理对象空间（可以在绑定之前激活指定序号纹理以控制纹理效果）
使用纹理数据生成纹理，自动生成 mipmap
顶点属性加入纹理坐标，Shader 利用纹理坐标。

## 渲染阶段
应用阶段：物理，动画等
几何阶段：顶点数据，顶点着色器，曲面细分，几何着色器，图元组装
光栅化阶段：连续变为离散，确定那些像素需要绘制，插值得到像素信息交给下一阶段
像素处理阶段：片段着色器，测试混合

## 帧缓冲
申请帧缓冲，绑定帧缓冲，创建附件，检查完整性，激活帧缓冲，删除帧缓冲
附件有两种选择，纹理和渲染缓冲对象。
    纹理在附加到帧缓冲时有提供三种可附加选项：颜色，深度，模板

    渲染缓冲对象本身和帧缓冲一样需要申请绑定，它不可读，只可写，读的话只能通过帧缓冲，它原生，性能更优
    如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。
    所以如果我们只是想采样颜色数据的话，在深度和模板上，我们可以使用渲染缓冲对象。

总结：
将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景
绑定默认的帧缓冲
绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。

## 混合
源 * 源因子 + 缓冲现有 * 目标因子

## 点乘叉乘应用
三维空间，我的坐标，前方向，敌人的坐标，如何判断敌人在我身后？
2D 空间三角形外一个点，如何判断点是否在三角形里？
叉乘符号是否相同
3D 空间三角形外一个点，其到三角形所在平面的距离如何求？
叉乘求法向量，然后用投影公式。确切来说，知道所求点到三角形点 A 的向量，确定法向量，利用向量点乘就可以求出夹角，然后已知斜边长度利用三角形勾股定理，可求直角边。

## 万向节
欧拉旋转，针对的是物体的初始状态，每次都是以初始状态为起点。
轴的顺序很关键，一般是 xyz，x 先旋转，然后 Y，然后 Z。这样在 Y 为 90 情况下，其实不论之前 X 如何旋转了，其效果和 Z 轴的旋转一样。
陀螺仪那边，有个形象直观的解释，X 带动 YZ，Y 带动 Z，当 Y 旋转 90，Z 和 X 重合。

## 四元数
1 维（实部） -> 2 维复数（实部加虚部）
2 维复数间的乘法 z * w，可以认为是 z * 1 * w，解释为将点 1 和 w 点所在的平面，以 0 为原点，1 为旋转锚点，将 1 旋转到 z 位置之后，w 对应的变化，即为 z * w.
总体理解为，左边是作为作用，右边作为点。

如何让一维理解二维旋转？
旋转其实也只有一个自由度，所以可以把所有的旋转集合映射到一维数组上。
方法有很多，这里介绍球极投影，用于将圆映射到数轴上，或者将球映射到平面上。
将 X （-1 到 1） Y （-i 到 i） 的单位圆，映射到竖轴 Y 上，可以从（-1， 0）向单位圆发送射线，射线和 Y 的交点就是映射点，所以对应的旋转就是数轴上的滑动，比如（1， 0），逆时针旋转 90 度，其实就是旋转到了（0， i）, 对于数轴来说，就是从映射点 0，到 i 的过程。
其中 i 和-i 在二维人看来是即使投影到 1 维也不变的点。

如何让二维理解三维旋转？
也是一样，让 Y 轴是实数轴，XZ 轴是虚部轴，一样从 Y = -1. 投射
其中在三维人，看来属于赤道的单位圆，即使投影到 2 维，也是不变的线。

如何让三维，理解四维？
其实在四维人，看来，属于单位球的部分，即使投影到 3 维，也是不变的面。
就是实部为 0 的四元数。
实部 0-1 的四元数，被投影到这个单位球内部
同样需要注意，我们在用整个三维空间描述一个单位四元数，所以，我们的三维中的任何点的模都相等。
正如二维空间投影的每一个线对应三维一个圆
三维空间投影的每一个面对应四维一个球（经过-1）
四元数和点乘叉乘关系？

## 遮挡剔除
基础：包围盒与视锥是否相交计算剔除

空间划分询问 BVH
BVH 组织场景中的物体为树形结构，父节点包围子节点的区域。当进行可见性测试时，首先检测光线或视锥体是否与上层的包围体相交，如果没有交集，所有子节点可以被剔除，避免不必要的详细计算。

优点：
高效性：通过直接使用包围体进行空间划分，可以快速排除不相关的对象。
动态：适合动态场景中的对象管理，能够迅速更新。

缺点：
构建开销：初始构建 BVH 结构可能会有较高的开销，在动态场景中需定期更新。
依赖于包围体：包围体的选择和设计需要合理，否则可能导致剔除不充分

PVS 是一种针对静态场景的可见性剔除技术，预先计算场景中每个区域或物体在不同视点下可能被看到的物体集合。
工作原理：在静态环境中，对摄像机的每个潜在位置进行视锥体剔除，创建一个包含所有可见对象的列表。渲染时，可以直接使用此列表进行快速剔除。

优点：
预计算高效：一旦计算完成，渲染时可以很快访问可见对象，节省实时计算时间。
适用于大规模静态场景：能够高效管理和渲染大型场景，如游戏关卡或建筑模型。
    
缺点：
静态场景限制：只适用于静态场景，对于动态物体，PVS 需要频繁更新。
内存占用：预计算的可见性信息可能占用大量内存，尤其是场景复杂时。

## 光的挑战阴影和 GI
第一挑战：阴影
第二挑战：如何在硬件上高效积分
第三挑战：任何物质都会成为光源，光源复杂

阴影：shadowmap
积分计算：改用简单计算
光源复杂，各种反射，任何东西都能成为光源：主光加环境光

shadowmap：
从光的视角渲染一张你的场景，拿到深度，用来标识你到光所在点的距离（这个距离可能被其他东西挡住导致距离很短）。然后当相机在正面渲染的时候，每个点，通过反向投影，得到光源视角的 projection，可以得到一个距离，如果这个距离大于最近的遮挡物距离的话，说明在 Shadow 中，反之亦然。

主光+各种环境光+全局光照
全局光照：
1：lightmap: 光照贴图（离线计算全局光照）：将所有场景参数化为巨大的 2D 光照图集（UV Atlas）：将三维空间复杂的几何投影到二维空间（参数化展开）（复杂几何简化，然后参数化分配，其中需要注意的一个需求，尽可能在同样的面积或者体积里面，分配的 texture 精度基本类似）

优势：
    因为是离线烘培，运行游戏时，很高效
    可以烘培出很多细节
缺点：
    非常长的烘培时间
    只能处理静态的物体，静态的光（其实也可以动态 lightmap 但是一般不会这么用，俗称丧心病狂）
    对于大场景有较大储存成本
    *参数化算法比较麻烦，写不好就一堆 BUG

空间换时间：用存储空间把大量的预计算放在这儿
把整个场景参数化到二维的 texture 上去（或者参数化到非常容易管理的地方）

2：Probes In Game Space：覆盖游戏场景的光照探针：一个点上的光照可以用一个半球来表示，那我在游戏场景上以一定比例布置一堆这样的点，这样在场景里的任意一点都可以用 4 面体插值来计算光照

优势：
    运行效率非常高
    可以应用于静态和动态对象
    处理漫反射和镜面阴影
缺点：
    一堆 SH 光探头在运行中需要一些预计算（可以每隔几帧一算，或者检测变化程度来获取计算时机）
    不能处理 GI 的细节。例如，重叠结构上的软阴影（软阴影存在半影，硬阴影非此即彼）。（毕竟比 lightmap 少了很多点位）

## 物理材质
基础理论：微平面理论：微面的法线分布：集中即光滑，分散即粗糙
最常用的模型：GGX 模型（不知道为啥叫 GGX），其中双向反射分布函数 BRDF（Bidirectional Reflectance Distribution Function）就是描述表面入射光和反射光关系的。

## 地形
高程图网格：
方法一：三角形剖分（Triangle-Based Subdivision）：永远把等腰直角三角形最长一边切分，永远切分成两个等腰三角形。
方法二：四叉树剖分（QuadTree Based Subdivision）：正方形切分，然后合并。这个方法暗含了资源管理的思想，其优点也是易于管理地形上的数据，包括筛选和存储；缺点是不像三角形那样灵活。
方法三：三角形不规则网络（Triangulated Irregular Network）：对于一些平平的山坡、平原，就用大三角形铺一下，对于细节很多的凹凸不平的，重要处理下。
优点：运行时渲染快（因为预处理了）；某些地形类型的三角形更少；
缺点：需要特定的预处理步骤；可重用性差；

方法一二为均匀采样，方法三为重要性采样。

方法四：GPU 追问细分：实时的细分方案

地形的材质混合：透明度混合；高度 01 混合；透+高；Texture Array 权重混合（注：3D Texture 和这个不一样）；
经典的材质混合把所有的材质都拿出来放到 array 里很费时费力，但实际上我们不需要这样做，我们只需要把看到的需要的拿出来就好，就像缓存，此为：Virtual Texture
1：创建一个虚拟索引纹理来代表整个场景的所有混合地形材料
2：只加载基于视图依赖 LOD 的瓷砖材料数据
3：预焙材料混合到瓷砖中，并将其存储为物理纹理

## 环境遮挡 AO
1：预计算 AO：用于角色贴图
2：运行时 AO：用于环境渲染
3：屏幕空间环境遮挡：Screen Space Ambient Occlusion (SSAO)：拿到屏幕的一张图，反向追踪其中每一个像素点，以此点为中心，画一个球并在球里面随机撒上一堆点，再利用深度图取得可以看到的点的数量和不能看到的点的数量，然后百分比扣算光强。但是其实这个是不对的，因为我们都知道光强是半球。
4：SSAO+：利用法线取半球，再进行计算。但是这个简单的算法会有一些错误的效果，比如一个点 A 在 100m 远，距离摄像机 10m 远有一个 C 点挡住了 A 点，自然 A 点看不见，但是按照 SSAO，A 点旁边的 B 点在计算光强的时候很有可能被 C 点群挡住了大部分半球，导致错误的阴影。
5：HBAO：Horizon-based Ambient Occlusion：使用深度缓冲区作为 2D 表面的高度场，在 2D 中直接跟踪射线，从地平线角度近似 AO。
具体实现：以一定步长选点，向半球放射随机稀疏射线，在一定距离范围内检测遮挡，最后选出最高点。（这里需要说明的是，学过信号系统的都知道，以固定频率稀疏采样出来的会有问题，所以要随机采样）然后根据高度遮挡关系计算接受的光强。
6：GTAO：HBAO 忽略了直射光和斜射光的区别，即 cos 角度对于光强贡献值的区别，GTAO 引入了缺失的余弦因子，删除了衰减函数，并添加了一个快速的多次反弹近似（模拟 GI，GI 和 AO 在效果上是互补的。）
7：RTAO：Ray-Tracing Ambient Occlusion

## 抗锯齿 AA
aliasing 的原因：屏幕像素有限，而想要表达的世界像素非常高。
几个例子：边缘、大物体、高光流动
AA 核心思想：基于屏幕的抗锯齿方案的一般策略是使用采样模式来获得更多的样本，然后对样本进行加权和求和以产生像素颜色
SSAA：Super-sample AA：直接超采样，比如 SSAA 4x，你要绘制多大分辨率的图，我直接乘以 4，然后采样显示。这样相当于那些 shader 都是 4 倍的量了。很费。4 倍渲染分辨率，4x z-buffer 和 framebuffer，4 倍光栅化和 shading。
MSAA：Multi-sample AA：硬件支持，区别于 SSAA，4 倍之后看一下，如果这 4 个都是一样的点，那就不需要走 4 遍了。变成一次采样，相当于只对于边角真正的 4 倍。只需要多采样所需的像素，4 倍渲染分辨率，4x z-buffer 和 framebuffer，4 倍栅格化和 1+ xshading。
两者问题：现代渲染的三角形数量可能都会远远超过像素数量，这样就无法 4 倍超采样了。

FXAA（快速近似抗锯齿） (Fast Approximate Anti-aliasing)：基于 1x 渲染图像的抗锯齿 （十字滤波 + 经验公式 找边界）
    根据亮度找到边缘像素（跳变像素）（这里的像素亮度有个颜色影响经验公式 (L = 0.299 * R + 0.587 * G + 0.114 * B)）
    计算每个边缘像素的偏移量 （先找到混合方向，然后沿着方向的两边垂直方向找到边界进行混合计算决定此点的偏移）
通过偏移量重新采样边缘像素以与邻居混合

TAA（时间抗锯齿）(Temporal Anti-aliasing)：利用时空滤波方法提高 AA 运动稳定性。问题是运动过程可能会感觉有点点 offset.（鬼影优化）

## 后处理
Bloom：光晕。光晕的物理基础是，在现实世界中，镜头永远无法完美聚焦，即使是完美的镜头也会用 Airy disk 对入射图像进行卷积。
    取出高亮的部分：先取出亮度，当亮度超过阈值（magic number）取出这个像素点（颜色和亮度）
    然后进行金字塔高斯 Blur：先把图像分辨率缩小再缩小，然后 Blur 一次，和对应缩小图混合，然后放大，然后再 blur，和对应缩小图混合，再放大，类似的，最后将 Blur 图和原图进行混合。
Tone Mapping：色调映射。色调映射功能的目的是将高动态范围 (HDR) 的大范围颜色映射为显示器可以输出的标准动态范围 (SDR)。（使屏幕模拟更加逼近现实中的人眼感知）
Color Grading：颜色分级。本质上只是一个原颜色到新颜色的映射，效果类似于滤镜。思路是以原颜色的 RGB 值为坐标，采样一张纹理，得到新颜色，这张纹理叫做 LUT（Lookup Table）。

## 历史渲染管线

1. Forward Rendering：前向渲染：将物件串成一个队列，一个接一个的进行渲染。可以以光源为主循环也可以物体为主循环。

    （注意一点：透明物体要在不透明物体之后渲染，同是透明物体，离相机远的先渲染）

    - 优点：符合直觉，简单
    - 缺点：当物体或光源较多时效率低下，且会有比较多的重复计算，overdraw 较高。

2. Deferred Rendering：延迟渲染：两个 Pass：

   - Geometry Pass：完成物体的几何数据处理，将光照计算所需要的数据（深度图、漫反射贴图，法线贴图，镜面反射强度图等）提取出来写入到不同的 GBuffer 中。
   - Lighting Pass：根据 G-Buffer 的数据，进行光照计算，写入 FrameBuffer 中。

    - 优点：
        - 光照只计算可见片段；（已经有深度图，会节省很多计算）
        - G-Buffer 中的数据可用于后处理 ；
    - 缺点 ：
        - 高内存和带宽成本（较大的带宽需求使得某些硬件无法使用）
        - 不支持透明对象（因为到光照那一 Pa，已经就只剩图了，分不出来物体）
        - 对 MSAA 不友好（4x，更慢）

3. Tile-based Rendering：分块延迟着色。分块渲染，减少带宽需求。

   - 生成 G-Buffer，这一步和传统 deferred shading 一样。
   - 把 G-Buffer 划分成许多 16×16 的 tile，每个 tile 根据 depth 得到 bounding box。
   - 对于每个 tile，把它的 bounding box 和 light 求交，得到对这个 tile 有贡献的 light 序列。
   - 对于 G-Buffer 的每个 pixel，用它所在 tile 的 light 序列累加计算 shading。

4. Forward+：前向渲染加上 Tile 切分。在 XY 屏幕空间中划分 Tile 进行光源过滤来降低消耗。三个 PASS：
   - Depth Pass：获取屏幕空间的 Depth 数据，方便下一步进行逐 Tile 的 Light Culling，也是为了避免后面 Geometry Shading Pass 的 Overdraw。
   - Light Culling Pass：划分 Tile，得到有贡献的 light（这里有一个深度优化，Min/Max，上面方法里光根据深度处理时也会用到，是一个常见优化）
   - Geometry Shading Pass：shading

5. Cluster-based Rendering：相比于 XY 切分，加入深度，进行 3D 的更进一步切分，进一步缩小光的影响范围，降低光照计算的浪费。（注意一个细节，近处切分密集，保留更多细节，远处大块一些，这样也更有性价比）

6. Visibility Buffer：几何 Buffer，反向去找材质啥的，这个在前沿这种三角形远多于像素的情况有采用，未来科技。在 framebuffer 里写几何体 ID，反向去查这个三角形材质，从而直接 shading。自行光栅化效率还是很高的。

## 屏幕撕裂

屏幕撕裂：因为屏幕刷新率固定，如果游戏因为某一帧卡顿，可能导致 B 帧的上半部分和 A 帧下半部分呈现给玩家。
    V-Sync：垂直同步，如果某一帧比较卡，超过了屏幕刷新时间，那么让下一次的屏幕依然显示上一次的画面。缺点是如果显示器刷新频率比较慢，可能会感觉到屏幕一会儿快一会儿慢。
    Variable Refresh Rate：自动调节显示器刷新频率，调成和游戏帧率一致。

## 光照

Photon Mapping：以前都是从相机去看，这里从光那里去看，弹几次停在物体表面，最后相机看的时候就看物体表面停了多少。
RSM（Reflective Shadow Maps）2005：从光的角度出发拍一个图，就获取了光直接照射的所有点，然后再从摄像机角度拍一个图，就获取了你想看到的所有点，这个时候你想看到的点的光强就可以利用之前光看到的那个点图再进行散射到摄像机的点图上来获取光强。
像素这么多，每个做一遍？别了。使用 Cone Tracing/低频采样。
低频采样有可能有的关键像素无法得出可信的数据，那就单独对这些点进行高频采样。
很酷的想法：易于实施；RSM 光子注入（住入）；mipmap 中的锥形采样；低分辨率间接照明与错误检查；
缺点：单次反弹；没有间接照明的可视性检查；

Voxelization Based Global Illumination (VXGI)：基于体素化的全局照明（取代 SVOGI）（以锥形描述光，根据表表面粗糙程度进行反射）
将体素数据存储在 clipmap 中：多分辨率纹理；靠近中心的区域具有较高的空间分辨率；似乎很自然地映射到圆锥追踪需求。
clipmap 比 SVO 更容易构建：没有节点，指针等，由硬件处理。
clipmap 更容易阅读。

打包好的 clipmap 就不动了，摄像机移动的时候只要把需要更新的去更新就好了，大部分不需要重新去弄。

问题是锥形光容易漏光错误

Screen Space Global Illumination (SSGI)：屏幕空间全局照明。
很简单的思想，屏幕空间有一个点，我们直接通过摄像机和他的位置找找看哪里的点是他的光源（这里有一个 high Z 的算法，快速找到这些点）
相邻点起始都是类似的，可以重用一些。
优点：光滑和镜面反射很快；质量好；无遮挡问题。
缺点：屏幕外信息缺失；邻居射线重用的不正确可见性的影响。

# 7.30

- C++ 多态的实现机制？ 其实问的就是虚函数表。
- 重写和重载的区别？这个太学术了，没啥意义，就各是各，不相干的两个东西，属于学术问题了，知道重载是啥就行。
- 构造函数 和 析构函数 可以是虚函数么？
- 智能指针怎么去计数的？
- 纯虚函数和虚函数区别？

# 厦门勇仕

- 向量点乘判断前后
- 四元数和欧拉角
- 字典的原理，字典如何有效存储数据；遇到两个特别大的结构体，有什么比较好的存储方法；子典怎么序列化
- 
- 
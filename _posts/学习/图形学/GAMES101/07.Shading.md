# 画家算法

先画最远的物体，逐渐画近的物体，让近的物体覆盖远的物体。看起来是没问题的。但不是总生效的。

![alt text](经典三角形相互遮挡问题.png)

这张图三个三角形互相遮挡，没办法定义深度关系，就不能采用画家算法

# Z-Buffer

既然没办法判断三角形整体的深度，那么就判断每个像素的深度，像素内记录像素深度最浅的几何，对于深度来说，越小越近，越大越远，在渲染时不光要存渲染的图，也要存一张深度的图。

对单个像素来说，逐步记录深度。如先画地板，先记录地板深度，物品来了后，比对物品的深度和记录的深度，发现物品深度小于记录的地板深度，说明物品要遮挡住地板。

![alt text](Z-Buffer.png)

暂时假设不存在深度相同的像素。在浮点数的表示中，两个浮点数完全相同的概率很小。（实际上会有相同深度的，但本课中暂不考虑）（透明物体 Z-Buffer 也处理不了，需要其他方法处理，暂不考虑）

注意！如果你使用了 MSAA 超采样了，深度图其实是对应采样点的深度信息，也就是那四个采样点的深度分别计算！

# 着色

对不同的物体应用不同材质的过程叫做着色

# Blinn-Phong 模型

镜面反射 + 漫反射 + 全局常亮光照

# 局部着色

着色不考虑其他物体的存在，其考虑的只是当下要渲染的那一个点，以及围绕这个点所产生的 单位法向量，单位光照方向向量，单位观测方向向量  以及这个计算中产生的 Blinn-Phong 模型。这叫局部着色，这一步不会考虑阴影，也就是不会考虑其他物体遮挡光照投射到物体身上的过程。

# 光的能量

同样的光，以不同角度照上去，明暗不一样

物体表面法向量n，和光源方向l，的夹角θ，决定了明暗强度

![alt text](光的吸收.png)

可以把光当成能量，吸收的越多越亮

# 能量守恒

光的能量都集中在一个球壳上，一开始球壳的表面积很小，考虑到能量守恒的话，那么单位面积上光的能量就很多，光越向外扩散，单位面积的能量就越小

![alt text](球的光照能量守恒.png)

通过球面公式可以计算出，距离光源为r的球壳上，单位面积上能量为I/r²

## 疑问

目前来说似乎能量守恒没有考虑观察点到物体表面的距离产生的影响，这一部分涉及到辐射度，之后再说

# 漫反射公式

![alt text](漫反射公式.png)

I/r² 表示有多少光到达了ShadingPoint（因为光会随着传播距离而衰减）

Kd表示了该点颜色的反射率

- 如果Kd=0，那么该点完全没有反射光出去，该点吸收了所有光，那么该点表现黑色
- 如果Kd=1，那么该点反射了所有光，那么该点表现为白色
- 如果用RGB三个通道表示Kd，那么Kd就是Color

Max（0，n·l）表示反射角度，nl都是单位向量，n·l = cosθ，当入射光从表面下面照入，θ>90°，cos<0，这种情况没有意义，因为我们只考虑反射光，不考虑折射等光线穿透，所以需要和0比，取最大值

漫反射和观测方向无关

# 着色点

着色是在某一个 shading point 上，在对应一张图，大概就是这么一个点，在这个点上来计算它，然后要想得到一整张图，那我们势必要应用这个着色很多次。

着色的频率是个问题

# 高光

当观察方向接近镜面反射方向的时候  <=>  法线方向 n 接近于 半程向量 h

![alt text](高光角度.png)

Phong 模型求 R 和 V 的接近程度

Blinn-Phong 模型 巧妙地把 R 和 V 的接近程度 转换为 n 和 h 的接近程度

知道两个单位向量l和v，求他俩的角平分线向量很简单，将两个向量相加，并求归一化

## NH 项的指数容忍度

向量之间的夹角余弦确实可以衡量两向量是否接近，但容忍度太大了

在一次幂的cos曲线下可看到，当夹角很大时，仍然有很大的值，这样生成的高光就会很大

正常情况下，我们认为高光都是很小很亮的

![alt text](cos指数容忍度.png)

随着指数增加，能看到在大约0~30°之内才可以看到高光，这样就算一个合理的模型

在布林冯模型下，一般来说，指数选在100~200之间，高光角度大约在3~5°之间，算是比较真实的

## KP

![alt text](高光参数KP.png)

纵向来看，反射系数Ks越大，高光越亮

横向来看，指数p越大，高光越小

# 环境光

一个茶杯，在光源并没有直接照射的方向上也有一定的亮度，因为一个光线可以弹射很多次，从四面八方打到任何一个点，这些光照就算是环境光照

由于环境光照非常复杂，这里我们假设一个点受到的环境光照永远都是相同的，强度称为Ⅰa

任何一个点都有自己的颜色，Ka相当于环境光的系数

可以近似的得到一个环境光La = KaⅠa

![alt text](环境光.png)

# 布林冯反射模型公式

![alt text](布林冯反射模型公式.png)

# 缺点

如果有一个凹进去的点，按理来说其不应该有那么强的环境光照射，但是按照这个公式来看，就是会导致有光。

# ShadingFrequencies 着色频率

![alt text](什么导致了着色频率不同.png)

FlatShading（面着色）：三角形面作为法线计算的依据！

GouraudShading（顶点着色）：三角形顶点作为法线计算的依据！

PhongShading(像素着色)：phong 着色，并非 blinn-phong 着色

三种着色频率产生的效果也取决于模型本身

每一行的模型本身顶点数是一样的，越往下顶点数越多

当几何足够复杂时用FlatShading得到的效果也很好

反过来说，当几何的面数大于像素数量时FlatShading的性能也不会好于PhongShading

![alt text](模型三种着色和复杂程度关系.png)

# 如何求逐顶点的法线

将和顶点相邻的面的法向量做加权平均

如何求顶点相邻的面（几何信息会告诉你）

![alt text](顶点法线算法.png)

# 如何求逐像素的法线

已知顶点法线，如何求中间某一点的法线---->插值、重心坐标

![alt text](像素法线算法.png)

# 渲染管线

顶点处理：将三维空间的点投影在平面上

三角形处理：将这些点连接形成三角形

光栅化：将三角形离散成为屏幕上的 Fragment（未经处理的像素）

着色：给像素上色

后处理：深度缓冲-处理遮挡关系，MSAA等抗锯齿

## 实例

MVP变换 --- 顶点处理：MVP变换本质上就是将不同的顶点进行变换

对像素采样 --- 光栅化

判定fragment是否可见 --- Fragment处理：Z-Buffer 深度测试

Shading --- 顶点 或 像素处理：如果用的是GouraudShading，那么进行的就是顶点处理；如果用的是PhongShading，那么进行的就是像素处理

# Shader

现代GPU中，这套渲染管线某些部分是可编程的，可以由开发者去定义顶点/像素如何着色

也就是用代码控制如何着色

这部分代码就叫Shader

Shader指定的是每一个像素/顶点如何着色，所以不能也不用去指定某一个像素如何着色

如果写的是顶点操作，这个shader就叫做VertexShader（顶点着色器）

如果写的是像素操作，这个shader就叫做FragmentShader（片段/片元着色器）/PixelShader（像素着色器）

# 纹理映射

我们希望得到一个三角形，三角形里面映射了一张图片，怎么得到？ 

以球来说，我们发现不同位置有不同颜色，球整体其实公用同一个着色模型，唯一区别就是漫反射系数Kd不同

我们希望有一种方法，可以定义一个物体上任意一点的基本属性

3D物体的表面其实都是2D的，比如地球仪，将地球仪上的图撕下来，可以平铺成一张2D的图

物体的表面，通过这种方式可以和一张图有一一对应的关系，这张图就叫纹理

将这张图平铺/裁剪/拉伸到任何物体表面，就叫纹理映射

空间上模型的三角形怎么对应到纹理上的三角形？

由美术同学提供

纹理上的坐标系通常以UV来表示

通常约定U和V的范围[0,1]

当纹理不断重复贴到模型上，可以得到不错的效果，虽然看纹理效果可以看到两张纹理之间有很明显的变化，但是在场景中很自然的无缝衔接

说明这个纹理本身设计的好，这种纹理叫TilableTextures  王氏砖

这种纹理的设计也是很值得研究的

纹理和着色的区别：纹理可以理解为一个底色

# 插值

## 为啥需要插值？

因为我们要表现顶点中间位置像素信息

## 插值的值都有哪些？

颜色，法线

## 怎么做插值？

重心坐标

# 重心坐标

在三角形ABC所在的平面中任意一点（x，y），都可以用三角形三个顶点的线性组合来表示

ABC 顶点前面的系数 α + β + γ = 1  这样其实就是说其实两个数确定了，第三个数也就确定了，很合理，因为二维坐标，就应该两个数确定。

（α ， β ， γ）可以用来描述此三角形的重心坐标

如果点在三角形内，会符合另外一个条件 α  β  γ 都必须 ≥ 0

![alt text](A的重心坐标.png)

![alt text](三角形内部一个点分割而成的三角形面积和其点系数关系.png)

设三角形内一点，点P，连接PA，PB，PC，会形成三个小三角形Aa，Ab，Ac，P的重心坐标就是小三角形面积占大三角形面积的比

α = Aa/(Aa + Ab + Ac)

所以可以求一个特殊的点，三角形重心，三角形重心将三角形划分为三个等面积的小三角形。

所以三角形重心的重心坐标为

![alt text](重心坐标.png)

## 投影变换性质

对于三维空间中的点，不能保证其被投影后的重心坐标不变

如果想插值三维空间中的属性，就应该插值三维空间中的坐标。

因为在做光栅化时，需要知道像素中心在三角形的什么位置，此时不能直接求重心坐标进行插值

需要将该点重新投影回三维空间中，在三维空间中计算重心坐标插值

这一点你想想深度就知道了，就是应该在原来的未投影的三角形上求

# 纹理插值

屏幕上的采样点（x,y）可以用重心坐标算出在纹理中采样的uv，得到对应纹理

# 第一个问题：纹理放大

当低分辨率纹理应用到高分辨率的屏幕上，纹理就会被拉大。

![alt text](纹理放大三种处理.png)

## Nearest

对于任意一点，可以找到对应纹理上的位置，位置可能不是整数，将位置坐标四舍五入，然后取纹理上的值

这样的话，一个texel就可能会被映射到多个pixel上，也就说可能在3*3的像素内用了同一个纹理的元素（texel）

这样就会产生马赛克效果如图 Nearest

## 双线性插值

先用U01  U11插值出来U1

再用U00 U10插值出来U0

再把U0和U1进行插值，得到红点的最终值，即为双线性插值

之所以叫双线性，是因为水平和竖直都用了插值（水平两次，竖直一次）

![alt text](双线性插值.png)


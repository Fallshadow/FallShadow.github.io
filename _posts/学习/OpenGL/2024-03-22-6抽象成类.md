---
layout: post
title:  "6 抽象成类"
date:   2024-03-22
categories: OpenGL
---

本文介绍了如何把渲染流程抽象成类。  

[1 顶点缓冲类](#顶点缓冲类)  
&emsp;[1.1 抽象分析](#抽象分析)  
&emsp;[1.2 代码应用](#代码应用)  

## 顶点缓冲类
#### 抽象分析
在不使用类包裹时，其基础操作是：申请缓冲区、绑定缓冲区、绑定数据。然后就是给顶点数据解读数据了，这部分不属于顶点缓冲。  
从全局来看，我们顶点缓冲，其实就是把顶点数据绑定到了指定标志区，之后都是OpenGL跟默认的标志区打交道了，无非就是绑定和解绑。所以综合来看，我们这个类只需要完成三个任务，即申请缓存绑定数据到指定标志区、解绑、重新绑定标志区。  

申请缓冲区需要一个无符号整型作为ID，而外部不需要得知这个ID，可以保存为私有变量。绑定数据需要原始顶点数据和申请空间大小，这部分顶点缓冲类并不需要保存，因为一旦绑定，就不需要变动，顶点缓冲类没必要知道这些细节，所以只需要用就行，不用保存为变量。为三个功能创建方法，
#### 代码应用
VertexBuffer.h
```Cpp
#pragma once

class VertexBuffer
{
private:
	unsigned int m_RenderID;
public:
	VertexBuffer(const void* data, unsigned int size);
	~VertexBuffer();

	void Bind() const;
	void UnBind() const;
};
```
VertexBuffer.cpp
```Cpp
#include "Render.h"
#include "VertexBuffer.h"

VertexBuffer::VertexBuffer(const void* data, unsigned int size)
{
	GLCall(glGenBuffers(1, &m_RenderID));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RenderID));
	GLCall(glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW));
}

VertexBuffer::~VertexBuffer()
{
	GLCall(glDeleteBuffers(1, &m_RenderID));
}

void VertexBuffer::Bind() const
{
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RenderID));
}

void VertexBuffer::UnBind() const
{
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
}
```
---
layout: post
title:  "0 QA"
date:   2024-03-21
categories: OpenGL
---

本文是所有的OpenGL问答。  
问答核心是考验对OpenGL的整体理解，不会细致到行行代码。问答内容分期，方便边学边复习。    

### 0 待注入知识
[双缓冲](#双缓冲)

### 1 OpenGL简介
[1：OpenGL是什么？其基础功能是什么？](#opengl是什么)  
[2：显卡与OpenGL的关系？显卡驱动更新一般意味着什么？](#显卡与opengl的关系显卡驱动更新一般意味着什么)  
[3：OpenGL两种模式？](#opengl两种模式)  
[4：OpenGL一大特性？](#opengl一大特性)  
[5：OpenGL本质是什么？编码风格是什么？什么语言编写的？](#opengl本质)  
[6：OpenGL对象是什么？](#opengl对象)  

### 2 构建环境
[1：如何在新电脑上利用从头测试OpenGL？](#如何在新电脑上利用从头测试opengl)  
[2：GLFW？GLAD？GLEW？](#glfw和glad和glew)  

### 3 绘制三角形
[什么是vertex buffer？简述在OpenGL中的使用方法！](#顶点)  
[什么是shader？顶点着色器和片段着色器？简述在OpenGL中的使用方法！](#shader)  
[图形渲染中所有的代码都在显卡上运行么？](#图形渲染中所有的代码都在显卡上运行么)  

### 4 绘制正方形
[什么是va？简述在OpenGL中的使用方法！](#顶点数组)  

### 5 错误处理
[OpenGL如何获取错误信息？](#OpenGL处理错误)  
[比较方便的处理错误的方法？](#我们处理错误)  


### 7 纹理
简述纹理

环绕方式、多级渐远、纹理过滤、stb加载、纹理单元

### 0
#### 双缓冲
单缓冲，绘图指令直接在窗口上执行，最终图像显示给用户的会是一个过程，按照从左到右、从上到下逐像素渲染而成。  
双缓冲，绘图指令在后台生成下一帧图像，然后通过交换指令直接呈现给用户。

### 1
#### opengl是什么
是一种规范，由XXX团队指定的，它不是API，只指定了函数的参数、表现和输出，具体实现细节由对应开发者决定。  
OpenGL的最基础的功能：那里有一堆数据，用它们画出一些东西，就仅此而已。
#### opengl的制作者
#### 显卡与opengl的关系显卡驱动更新一般意味着什么
显卡厂商实现具体逻辑，驱动更新一般意味着新特性或者修复BUG。
#### opengl两种模式
立即渲染模式 更快速，隐藏细节。   
核心模式    更现代化，要求编写人员了解渲染原理。
现代OpenGL都是核心模式，这样更灵活。
#### opengl一大特性
扩展，显卡厂商有什么新优化或者新效果，直接在驱动上扩展就可以，一些成为主流的特性甚至会被opengl看中，收入其中
#### opengl本质
状态机，设置上下文，然后应用上下文，C语言
#### opengl对象
在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体。

### 2
#### 如何在新电脑上利用从头测试opengl
需要用现有的库glfw创建窗口，用现有的库glad或者glew来调用驱动写好的OpenGL函数。  
下载好两个库，然后把包含文件和库文件在项目中配置好，就可以用了。
#### glfw和glad和glew
我们需要一个窗口来执行渲染，但是不同平台、不同显卡驱动创建一个窗口的代码也不同，我们不必知道这些细节，GLFW库就是帮我们省掉这部分麻烦的。GLFW是一个免费的开源多平台库，用于OpenGL、OpenGL SE 和 Vulkan应用程序开发。它提供一个简单的、独立于平台的API，用于创建窗口、上下文和表面、读取输入、处理事件等。  
创建完窗口我们还需要从显卡驱动中拿到我们需要使用的函数，然而这些函数都在驱动dll中，我们如果想用哪个函数，就需要手动链接指定指针，这样太麻烦了，同样我们借助库来解决。GLAD就是用来管理函数指针的，它提供了很多函数，是GLEW的升级版。

### 3
#### 顶点
先不看名字里的vertex，它首先是一个buffer，其本质就是一个位于显存上的字节数组，就只是个内存缓冲区，即VRAM，Video RAM。至于vertex，那是根据我们的用途起的名字，我们决定将这块内存缓冲区用来存储vertex。而其中的内容，就是一个个的顶点，顶点所包含的顶点属性可能有位置、法线、颜色、切线等等。  
在OpenGL代码中，要先申请缓存，让OpenGL为这块普通的缓存分配一个ID。然后绑定缓存，告诉OpenGL这段缓存我们要用于顶点。再绑定数据，告诉OpenGL我们要用多大空间，顶点数据是什么。最后我们还要依次启用顶点属性，并且定义这个顶点属性的数据类型是什么，有几个这种数据类型，此顶点属性从第几个字节开始，顶点之间的间距是多少。至此，顶点缓冲区的申请划分都表述清楚了。

#### shader
Shader就是一堆我们可以编写的可以在显卡上运行的代码。  
顶点着色器决定了顶点在屏幕上的位置，它也能对顶点做一些转换。  
片段着色器决定了每个像素的颜色。  
在OpenGL代码中使用shader，简单说就是从某处读取到shader代码并编译，编译无误后绑定到创建的程序对象中进行链接，链接无误后，告知OpenGL使用该程序，这时可以把之前的shader删除了，因为已经在程序里有了。至此已经可以正常应用这个Shader了。最后不要忘了删除掉这个程序。

#### 图形渲染中所有的代码都在显卡上运行么
事实上，仍然有一部分代码在CPU上运行更快，然后仅仅将计算后的数据发送给显卡使用。但这毕竟是少数，大部分事情都与图形相关，显卡的速度就会快很多，那里是shader的天下。




### 4
#### 顶点数组
va顶点数组是用来解释顶点缓冲区数据的，因为单纯分配空间绑定顶点数据之后，OpenGL并不知道这些数据应该怎样划分，那一块都代表什么，va就是用来解释数据分布的。  
va和vb一样，都是需要缓冲区存储的，va的标志区是GL_ELEMENT_ARRAY_BUFFER，而vb是GL_ARRAY_BUFFER，绑定数据的用法也是一样的，最后绘制的时候va使用glDrawElements，vb使用glDrawArrays。  
### 5
#### OpenGL处理错误
glGetError是OpenGL获取错误的一个方法，它能返回一个最早的错误标记码，每次返回一个并从错误栈弹出。这导致出错时，如果我们想知道是不是这个函数的问题，我们需要先清空错误，然后再执行函数，再获取错误。而且对于每个函数都是如此。而且这个返回值是一个标记，其具体含义需要查文档。

#### 我们处理错误
在debug下，对于每一个gl函数，我们都要进行错误检测，这样才能最大限度地防止出错无处可查的问题。而且我们还可以加上函数信息文件信息行数信息，来提示我们。还可以加上强制断点。  
不过记得在release下清除。

### 第三课
#### 1：翻译翻译图形渲染管线？渲染管线可以划分为的几个步骤？
将一系列3D坐标转换为2D像素的过程。  
从数据层面简单拆分为两步：3D坐标到2D坐标，2D坐标到2D像素。  
从OpenGL管线来说：输入顶点数据 到 顶点着色器 到 图元装配 到 几何着色器 到 光栅化 到 片段着色器 到 测试与混合
#### 2：3D坐标、2D坐标、2D像素？
#### 3：典型的着色器代码结构？
``` C++
#version version_number
in type in_type_name
out type out_type_name
uniform type uniform_type_name
void main()
{
    // 自定义操作变量
    // 最终输出
    out_type_name = xxxxxxx;
}
```
#### 4：顶点着色器的数据来源？
直接来源于顶点数据，使用layout(position = 0)之类的修饰去寻找指定属性解析
#### 5：顶点属性最大值由什么决定？
由硬件决定，我们可以使用这个函数查看最大值
``` C++
int nrAttributes;
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
std::cout << "Maximum nr of vertex attributes supported: " << nrAttributes << std::endl;
```
一般我们会得到16 这个基本够用了
#### 6：GLSL的数据类型和容器？
vecn,bvecn,ivecn,uvecn,dvecn
Vector Matrix
#### 7：向量的特殊写法？
重组：Swizzling。即向量允许这样的写法
```C++
vec2 myVec2;
vec3 myVec3;
vec4 myVec4 = myVec2.yy + myVec3.zx;
myVec4 = myVec3.zzzx;
myVec4 = myVec2.xxyy;
```
#### 8：着色器之间的信息传递？
需要同名同类型的In 和 Out相连。
#### 9：uniform是什么？怎么用？使用时需要注意什么？
uniform 是一个声明在Shader里的全局变量。所有Shader都共享这份名称的uniform。  
glGetUniformLocation从指定程序中获取到指定名称的uniform。
glUniformXT赋值给指定uniform（X为几位，T为什么类型，比如uniform vec4 Uniform_Color为4位float，即4f）
#### 11：标准化设备坐标？
#### 12：如何创建并使用一个着色器程序？
编译顶点着色器，编译片段着色器，链接它们到程序，然后释放它们，最后使用链接好的程序。

### 第四课 关于纹理？
#### 1：纹理的好处？纹理是由什么组成的？
单纯使用我们目前所学习的点位和颜色来绘制我们想要的图片简直是在折磨艺术家，并且这样的开销也是巨大的，我们需要无数的点位信息。所以不如艺术家绘制好一张图，然后让对应点位对齐这张图上的某点，剩下的使用OpenGL的功能分配这张图上的颜色值给需要显示的中间点位。方便快捷！  

纹理是由纹理像素组成的，当你放大一个纹理，你会看到一块块的纯色像素，这就是纹理像素，之后要给顶点属性用的。
#### 2：如何导入一个图像？

#### 3：什么叫做纹理采样？什么是纹理坐标？纹理坐标的范围？超出范围会怎样？
使用纹理坐标为片段获取对应的纹理颜色就叫做采样。  
纹理坐标从左下角（0，0）到右上角（1，1）。平铺在纹理图片上连续的值。  
超出范围之外的点位，可以选择以何种环绕方式来诠释自身颜色。
#### 4：纹理环绕方式？
纹理环绕方式分为str方向。(2D 3D纹理)。   
单纯重复：GL_REPEAT  
镜像重复：GL_MIRRORED_REPEAT  
拉伸：GL_CLAMP_TO_EDGE  
自定义边缘颜色：GL_CLAMP_TO_BORDER  
#### 5：大物体低分辨率纹理的问题？
大物体应用低分辨率纹理，会有很多顶点占据一个纹理像素的情况，这个时候各个顶点到底要应用周围哪个纹理像素的颜色值，就有方案可选了，这里主要介绍两点。    
邻近过滤，找到其中心点最接近此顶点的纹理像素，就选他为样本颜色了。（颗粒感分明）  
线性过滤，以其周围的纹理像素中心点距离作为权重分配标准去混合颜色。（模模糊糊）
#### 6：超远距离精细分辨率纹理问题？（悬而未决）
一个非常精细的纹理贴在一个1平方米的方形上并且放置在远处的山顶。。。。  
假设我们仅仅6个顶点去描绘这个方形。。。  
我们该如何采样？？？  
再使用高精细的纹理贴图显然不合适了，有一个方案是
#### 7：纹理单元？
一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元。OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。
#### 8：如何使用纹理？
``` C++
unsigned int tex_test;
glGenTextures(1, &tex_test);
// 使用图片生成texture
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, weight, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
// 生成多级渐远纹理（不可以省略）
glGenerateMipmap(GL_TEXTURE_2D);
// 绑定shader中的UniformTexture2D到0位置Texture
glUniform1i(glGetUniformLocation(MYShader.ID, "UniformTexture2D"), 0);

// 窗口循环运行部分 激活0 绑定指定texture到0上
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, tex_test);

// Shader里面 sampler2D 这种的叫做采样器
// uniform sampler2D UniformTexture2D;
// void main()
// {
//     FragColor = texture(UniformTexture2D, VertexOutTexture);
// }


// 开画
```




### 第五课
#### 1：坐标系统转换？各个空间、各个矩阵？
#### 2：裁剪空间中有图元的单个坐标超过了范围怎么办？
#### 3：透视除法？
#### 4：正射投影矩阵和透视投影矩阵都是如何计算的？
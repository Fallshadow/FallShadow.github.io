- [信息就是位+上下文](#信息就是位上下文)
- [程序被其他程序翻译成不同的格式](#程序被其他程序翻译成不同的格式)
- [了解编译系统如何工作很有益处](#了解编译系统如何工作很有益处)
- [处理器读并解释储存在内存中的指令](#处理器读并解释储存在内存中的指令)
    - [系统的硬件组成](#系统的硬件组成)
    - [如何执行一个程序](#如何执行一个程序)
- [高速缓存](#高速缓存)
- [操作系统管理硬件](#操作系统管理硬件)
    - [进程](#进程)
    - [线程](#线程)
    - [虚拟内存](#虚拟内存)

计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。

## 信息就是位+上下文

首先我们要知道计算机如何表示人类的信息，计算机本质上是 01 代码。一连串的 01 表示二进制数字，然后使用某些规则将数字映射为字符信息。目前大部分现代计算机系统使用的规则被称为 ASCII 标准，这种方式实际上就是用一个唯一的单字节大小（8 位二进制）的整数值来表示每个字符。只由 ASCII 字符组成的文件称为文本文件，其他都是二进制文件。

以 C 语言程序为例，其程序的生命周期从源程序（源文件）开始。源程序实际上就是由 0 和 1 组成的位序列。源文件中每个文本行都是以看不见的 '\n' 结束的。

这样的表示方法意味着：系统中所有的信息————包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、一个浮点数、字符串或者机器指令。

## 程序被其他程序翻译成不同的格式

以 C 语言编写的 hello world 程序为例，其生命开始于一个高级 C 语言程序，就是人们编写的 C 语言文件。但是，为了真正运行这个程序，人们编写的每条 C 语句，都必须转化为一系列的低级机器语言指令，并且打包成二进制文件存储起来供计算机使用。

以 C 语言程序为例，从源程序到目标程序要经历四个步骤：

1.  预处理：预处理器将源程序处理成修改了的源程序。
2.  编译：编译器再将源程序翻译为汇编语言程序。
3.  汇编：汇编器将汇编程序处理为可重定位目标程序。
4.  链接：链接所需的可重定位目标程序为可执行目标程序。

详细介绍：

1.  预处理器（cpp）根据以#开头的命令，修改原文件（#表示引入某个文件内容，插入到此文本中），仍然属于文本文件（从。c 到。i）;
2.  编译器（ccl）将文本文件。i 翻译成文本文件。s;
3.  汇编器（as）将。s 翻译成机器语言指令，将这些指令打包成一种叫做可重定位目标程序的格式（relocatable object program），并将结果保存在。o 中。这个。o 属于二进制文件，函数在这里变成了指令编码，如果使用文本编辑器打开。o 将会看到一堆乱码。
4.  链接器（ld）如果程序中使用了某些其他不存在此程序中的函数，需要额外以某种形式链接已经单独预编译好的目标文件。o，最后得到的文件就可以被加载到内存中，由系统执行。这种文件称为可执行目标文件。比如 printf 函数是一个标准 C 库函数，存在于 printf.o 中，这是一个单独的预编译好了的目标文件。链接器将其与汇编得到的二进制文件合并得到可执行目标文件。

## 了解编译系统如何工作很有益处

上边我们提到了程序的编译汇编链接这些看起来十分底层的东西，它们也许和我们能否编写出可运行的程序没有太大关系，却决定了我们编写“优雅”程序的上限。理解它们有如下好处：

*   优化程序性能：可以知道如何编程更加合理
*   更好地理解链接时出现的错误
*   避免安全漏洞：理解编译系统、学习汇编语言，就会更好理解堆栈原理和缓冲区溢出错误

下面是一些值得想象的问题：
switch 语句是否比一系列的 if then else 高效的多？
一个函数调用的开销是多少？
while 循环比 for 高效？
指针引用比数组引用更高效吗？
为何将循环求和的结果放到一个本地变量中，比将其放到一个通过引用传递过来的参数中相比，运行速度快很多呢？
为何只是重新排列算术表达式中的括号，既可以让一个函数运行快很多呢？
静态变量和全局变量的区别？
在不同的 C 文件中定义相同的两个全局变量，会发生什么？
静态库和动态库的区别？
在命令行上制定链接库，其顺序有何影响？
有些连接错误为何直到运行时才出现？

这些问题在接下来的学习中都会有解答

## 处理器读并解释储存在内存中的指令

#### 系统的硬件组成

主要包括总线、I/O 设备、主存储器、处理器四个部分

*   总线：总线一次可以传输一个定长的字节块，称为字。64 位系统即总线一次可以传输 64 位（8 字节），这里一个字就是 8 字节。
*   I/O 设备：每个 I/O 设备通过一个控制器或适配器与 I/O 总线相连。控制器是 I/O 设备本身或主板上的芯片组，适配器则是一块插在主板上的卡。
*   主存：由一组动态随机存取存储器（DRAM）组成。从逻辑上看，存储器是一个线性的字节数组，每个字节都有唯一的地址。
*   处理器：是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个程序计数器（PC)。程序计数器是一个大小为一个字的存储设备，存储 CPU 即将执行的下一条指令的地址。处理器就是在不断执行程序计数器指向的指令。每执行一条，程序计数器更新一次，指向下一条指令。处理器会按照指令执行模型（指令集架构）解释指令中的位并执行相应操作。每条指令的操作是围绕主存、寄存器文件、算数/逻辑单元（ALU）进行的。

寄存器文件：单个字长，有唯一的名字。
ALU：计算新的数据和地址值。

几个简单指令的操作：
加载：从主存复制一个字或字节到寄存器，覆盖原来内容
存储：从寄存器复制一个字或字节到主存，覆盖原来内容
操作：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并把结果存到一个寄存器中
跳转：从指令中抽取一个字复制到程序计数器中，覆盖原来内容。

区分处理器指令集架构和微体系架构：
指令集架构：每条机器指令的效果
微体系架构：处理器实际上是如何实现的

#### 如何执行一个程序

初始时，shell 程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串命令之后（假设此命令为让 shell 执行桌面的 hello 程序），shell 程序将字符逐一读入寄存器，再放到内存。当我们输入回车键，shell 程序得知命令结束，开始加载 hello 文件，这些指令将使得 hello 从磁盘达到内存（直接存储器存取技术（DMA），数据可以不通过寄存器而直接到达内存）。一旦数据到达内存，处理器就开始执行 hello 程序中的机器语言指令，最终输出到显示器。

整个流程：读取输入的命令 → 执行命令使得目标程序从磁盘存储到主存 → 执行目标程序指令  →  加载 helloworld 到寄存器 → 复制到显示器 → 显示

## 高速缓存

高速缓存（cache）用来解决处理器与主存间的性能差异。
L1 和 L2 一般使用一种叫做静态随机访问存储器的硬件技术实现（SRAM）。

> 静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM 储存的数据还是会消失（被称为 volatile memory），这与在断电后还能储存资料的 ROM 或闪存是不同的。

## 操作系统管理硬件

操作系统的两个基本功能：

1.  防止硬件被失控的应用程序滥用
2.  向应用程序提供简单一致的机制来控制复杂的低级硬件设备
    操作系统所应用的三个基本的抽象概念：
3.  进程：对处理器、主存和 I/O 设备的抽象表示
4.  虚拟内存：对主存和磁盘的抽象表示
5.  文件：对 I/O 设备的抽象表示

#### 进程

处理器看上去就像在不间断地一条接着一条地执行程序里的指令，即看上去该程序的代码和数据是系统内存中唯一的对象，这些假象是通过进程的概念来实现的。
进程：操作系统对一个正在运行的程序的一种抽象。

无论是在单核还是多核系统中，一个 CPU 看上去就像在同时执行多个进程，即看上去是在并发执行进程，但其实这是通过处理器在进程之间切换来实现的。操作系统实现这种交错执行的机制称作上下文切换。所以其实在任何一个时刻，单处理器只能执行一个进程的代码。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如 PC、寄存器文件当前值、主存的内容等。

#### 线程

一个进程由多个线程组成，每个线程都运行在进程的上下文中，共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，且线程一般来说比进程更高效。

#### 虚拟内存


## 快速上手项目的几件事

1：上手一个项目，首先可以看游戏测试场景（一般会把游戏中用到的资源放到 Objects 场景下，进行测试观察）。

2：可以分类查看资源，看看项目中的资源情况（一般也就是看个多少）。、

3：查看 graphic setting 相关设置。

比如前向渲染还是延迟渲染，垂直同步是否关闭，shader 启用情况等。

4：打包到手机上，连接 profile，查看渲染三角形等 status 信息。

## audio

### Mono 和 Stereo

mono 单声道，stereo 立体声。

在 unity 中两者显示不同：

![stereo](58ea3f76-7c93-44c8-8937-fae529118f23.png)

![mono](image.png)

在左右两个声道音频完全相同的情况下，不如直接开启 force to mono 。

![force to mono](image-1.png)

### 压缩

可以看到气泡中的原始大小和导入大小以及压缩比例。

一般极可能使用未压缩的 wav 文件作为源文件。

- PCM（未压缩格式）
    
    特点：无损音质，文件体积大。适合对音质要求极高的场景（如音乐游戏）。

    优点：无需解码，CPU 开销低，音质最佳。

    缺点：文件体积大，不适合存储受限的移动设备。

    适用场景：PC 或主机平台，存储空间和性能不是主要限制时的短音效（如 UI 声音），因为文件小且无需解码。

- ADPCM（有损压缩）

    特点：轻度压缩，音质接近 PCM，但文件大小显著减小（约为 PCM 的 1/4）。解码效率高，适合实时解码。

    优点：音质较好，解码开销低。

    缺点：压缩率不高，文件仍较大。

    适用场景：主机和 PC 平台，尤其是对音质要求较高的场景的中等长度的音效（如环境音、对白）。

- MP3（有损压缩）

    特点：高压缩率，文件体积小。解码效率较低，可能增加 CPU 开销。

    优点：文件小，适合长音频。

    缺点：音质损失明显，解码开销较高。

    适用场景：PC 和主机平台，适合背景音乐或长音频。不推荐用于移动端（解码效率较低）。

- Vorbis（有损压缩）

    特点：开源格式，压缩率高，音质优于 MP3。Unity 中常用的压缩格式，支持多平台。

    优点：音质好，文件小，跨平台支持。

    缺点：解码效率稍低于 ADPCM。

    适用场景：PC、主机和移动端，适合背景音乐或长音频。

- AAC（有损压缩）

    特点：比 MP3 更高效的压缩算法，音质更好，文件更小。广泛支持于移动设备和主机平台。

    优点：音质与文件大小的平衡较好。

    缺点：解码开销较高。

    适用场景：移动端和主机平台，适合背景音乐或长音频。

- Opus（有损压缩）

    特点：新一代音频格式，压缩率高，音质优异。支持动态比特率调整，适合网络传输。

    优点：音质与压缩率的平衡最佳。

    缺点：部分平台支持有限。
    
    适用场景：移动端和网络游戏，适合语音聊天或动态音频。

- HE-AAC（高效 AAC）

    特点：针对低比特率优化，适合流媒体和移动端。

    优点：低比特率下音质较好。

    缺点：解码开销较高。

    适用场景：移动端，适合低带宽环境。

在 Unity 中，可以通过 Audio Import Settings 设置音频的压缩格式和质量：

Load Type：
- Decompress on Load：适合短音效，减少解码开销。
- Compressed in Memory：适合中等长度音频，节省内存。
- Streaming：适合长音频（如背景音乐）。

Compression Format：
- PCM：无损音质，适合短音效。
- Vorbis：适合背景音乐。
- ADPCM：适合中等长度音效。

Quality Slider：设置压缩强度（通常 50%-75% 是较好的平衡点）。


### 采样率

音频采样率指的是每秒钟采样的次数，单位为 Hz（赫兹）。

- 44.1 kHz（44100 Hz）

    特点：CD 级音质，适合大多数音乐和高质量音频。是最常见的采样率，广泛用于音乐和游戏音频。

    优点：音质较高，适合背景音乐和复杂音效。兼容性好，几乎所有设备都支持。

    缺点：文件大小较大，解码开销稍高。

- 48 kHz（48000 Hz）

    特点：广泛用于电影、视频和高质量音频。比 44.1 kHz 略高的采样率，音质差异不明显。

    优点：更适合与视频同步（如游戏中的过场动画）。高端设备支持良好。

    缺点：文件大小和解码开销比 44.1 kHz 略高。

- 22.05 kHz（22050 Hz）

    特点：采样率减半，适合对音质要求不高的场景。文件大小和解码开销显著降低。

    优点：文件小，适合存储空间有限的移动设备。解码效率高，适合短音效或低端设备。

    缺点：音质明显下降，尤其是高频部分。

- 16 kHz（16000 Hz）

    特点：常用于语音音频（如对话、语音聊天）。文件大小和解码开销进一步降低。

    优点：适合语音内容，音质足够清晰。文件小，解码效率高。

    缺点：不适合音乐或复杂音效，音质较差。

- 8 kHz（8000 Hz）

    特点：常用于电话语音或极低音质需求的场景。

    优点：文件极小，解码效率最高。

    缺点：音质非常差，仅适合语音或简单提示音。

一般使用 44.1 kHz，短音效可以采用 22.05 kHz。一般移动平台 22.05 kHz 就够用了。

![sample rate](image-2.png)

采样率可以覆写。

### 加载方式

![loading](image-3.png)

- Decompress On Load : 音频文件在加载时会被完全解压缩到内存中。
        
        播放时无需解码，性能开销最低。
        适用于小于 200 kb 的需要频繁播放的简短音效（如 UI 声音、按钮点击、爆炸音效等）。
        如果音效文件较大，可能导致内存占用过高，尤其是在移动设备上。

- Comprssed In Memory : 音频文件以压缩格式存储在内存中，播放时实时解码。

        适合那些需要频繁播放但文件较大的音效。
        超过 5 秒，或者大于 200 kb 的复杂音效（如环境音、对白、较长的音效）。

- Streaming : 音频文件不会完全加载到内存中，而是以流式方式从磁盘或存储中逐步加载。

        播放时边加载边解码。
        较长较大的音乐文件，用流式加载避免载入时卡顿。
        会有额外 CPU 开销，但是值得。

### 静音做法

最好不要只是将音量设置为 0，而是把 audio source 清除。

## model

### 导出设置

- 统一单位：游戏模型的大小规范，不同软件之间的单位可能不相同
- 导出的网格类型：必须是多边形拓扑，不能是贝塞尔曲线、样条曲线、细分曲面等，这些 unity 都不支持。
- 确保所有的 Deformers 都烘焙到网格模型上。（如骨骼的形变已经烘培到蒙皮的权重上等）
- 不建议将模型中使用到的纹理、材质随模型导出，这会降低unity的模型导入效率，同时也让我们的资源目录变得难以管理。
- 如果你需要导入blend shape normals 时，必须指定光滑组 smooth groups.
- 导出时不要携带如摄像机，灯光材质等场景信息，因为这些与 unity 内部的默认设置都不同，除非你为 DCC 工具做了适配 unity 的自定义导出插件。

### 原始模型对性能的影响点（美术应该注意的制作细节）

- 最小化模型面数。

        尽量不要靠增加面数来增加细节。
        避免微三角形面（一个三角形只包含个位数个像素）。
        三角面尽量均匀分布。

- 合理化拓扑结构与平滑组：尽量将模型做成闭包，而不是通过没有焊接的面去组合。这可能引起后期 unity 下的烘焙错误，也会产生额外的三角形顶点和边

- 模型下尽量少的使用材质个数：材质数的增多，同样会引起 shader 和贴图的暴涨

- 尽量少的蒙皮网格：且同一个模型下尽量使用相同的蒙皮网格，如果真的有特殊需求除外。

- 尽可能少的使用骨骼数量：过多的骨骼数量后期可能引起蒙皮动画的 cpu 和 gpu 双方的性能瓶颈。

- 原始模型中的 fk 与 ik 骨骼接连尽量分离：由于unity中不支持导入的 ik 骨骼，在 dcc 工具中做好分离，方便导出时删除 ik 骨骼节点。

## unity 导入设置

- mesh compression

        unity 默认不开启。
        在保证网格准确的情况下，可以采用更加激进的压缩方式，可以使网格占用的磁盘空间更小。
        注意，在运行时的内存不会减少。

- read/write

        启用后，会在内存中额外复制一份此网格。
        一个副本会保存在内存中，另外一个副本会保存在 gpu 显存中。
        只有在运行时需要动态修改网格数据的时候，我们才需要开启此选项。
        skinmesh 一般也需要开启此选项来做动画。
        绝大多数情况下需要保持此选项关闭以节省内存。

- optimize mesh 和 generate colliders：默认就好，除非你要禁止优化，或者需要精确制作网格碰撞。
- Index Format ： 决定了模型的索引缓冲区格式，直接影响模型的顶点数量支持范围和内存占用。

        索引缓冲区：在 3D 渲染中，索引缓冲区用于定义模型的顶点连接方式（即三角形的绘制顺序）。
        16-bit：支持的最大顶点数为 65,536 (2^16)。
        32-bit：支持的最大顶点数为 4,294,967,296 (2^32)。
        如果你确定在移动平台做游戏，可以强制所有都用  16-bit 顺便来检测模型规范。

- 法线：法线是每个顶点的方向向量，用于确定光照计算中表面的朝向。

        - 光照计算：法线是光照计算的基础，用于确定光线与表面的角度。Unity 的所有光照模型（如漫反射、镜面反射）都需要法线来计算光的强度和方向。
        - 实时光照和阴影：如果模型需要参与实时光照（如点光源、聚光灯）或投射阴影，法线是必需的。
        - 法线贴图（Normal Map）：即使使用法线贴图，模型仍然需要基础法线来正确应用法线贴图的细节。
        - 环境光遮蔽（Ambient Occlusion）：法线也用于计算环境光遮蔽效果，增强模型的光影细节。

        法线生成设置：
        - Import（导入）：使用模型文件中自带的法线。适合在 3D 建模软件中已经生成了高质量法线的模型。
        - Calculate（计算）：Unity 根据模型的几何形状重新生成法线。适合简单模型或需要在 Unity 中调整法线平滑度的情况。
        - None（无）：不生成法线，模型将无法正确参与光照计算。适合完全不需要光照的模型（如 UI 元素、简单的装饰物）。

-  切线（Tangents）：切线是与法线和顶点方向相关的向量，用于支持法线贴图（Normal Map）的计算。

         - 法线贴图（Normal Map）：切线是法线贴图工作所必需的。法线贴图用于模拟表面细节（如凹凸感），需要切线来正确计算光照方向。如果材质使用了法线贴图，但模型没有切线，Unity 会报错或显示异常。
         - 高质量材质效果：如果模型使用了复杂的材质（如 PBR 材质），通常需要切线来支持法线贴图和光照计算。
         - 动态光照：切线在动态光照下（如移动的光源）尤为重要，因为它们影响法线贴图的动态更新。

        切线的生成设置：
         - Import（导入）：使用模型文件中自带的切线。适合在 3D 建模软件中已经生成了高质量切线的模型。
         - Calculate（计算）：Unity 根据模型的法线和 UV 坐标重新生成切线。适合需要在 Unity 中调整切线的情况。
         - None（无）：不生成切线。适合不使用法线贴图的模型（如简单的材质或不需要细节的模型）。

- 法线和切线

        法线：几乎所有需要光照的模型都需要法线，用于基础光照计算。
        切线：只有在使用法线贴图时才需要切线，用于支持法线贴图的光照计算。
        设置建议：
        如果模型需要光照但不使用法线贴图：启用法线，禁用切线。
        如果模型使用法线贴图：同时启用法线和切线。
        如果模型不需要光照：禁用法线和切线以优化性能。

-  Swap UVs：用于交换模型的 UV 通道 1 和 UV 通道 2。这个选项主要与光照贴图（Lightmap）和纹理映射相关

        UV 是模型顶点的纹理坐标，用于将 2D 纹理映射到 3D 模型表面。
        一个模型可以有多个 UV 通道（如 UV1、UV2），每个通道可以存储不同的纹理坐标：
        UV 通道 1（UV1）：通常用于主纹理贴图（如颜色贴图、法线贴图等）。
        UV 通道 2（UV2）：通常用于光照贴图（Lightmap）或其他特殊用途。

        Swap UVs 会交换模型的 UV1 和 UV2，即：
        原本存储在 UV1 的纹理坐标会被移动到 UV2。
        原本存储在 UV2 的纹理坐标会被移动到 UV1。

        - 光照贴图（Lightmap）相关
        在 Unity 中，光照贴图通常使用 UV2 通道。
        如果导入的模型中，光照贴图的 UV 坐标错误地存储在 UV1 通道，而主纹理的 UV 坐标存储在 UV2 通道，可以使用 Swap UVs 来修正。

        - 修复 UV 通道错误
        某些 3D 建模软件（如 Blender、Maya）导出的模型可能会将 UV 通道顺序弄反。
        如果发现模型的纹理或光照贴图显示异常，可以尝试启用 Swap UVs。

        - 特殊用途
        如果你需要在 Unity 中手动调整 UV 通道的用途（例如将光照贴图的 UV 用作主纹理 UV），可以使用 Swap UVs。

![setting](image-4.png)

vertex compression 选项是设置每个通道的顶点压缩。可为模型除位置、光照贴图uv之外的所有内容启动压缩。

optimize mesh data 可根据网格使用的材质删除不需要的数据，如材质中没有使用到的切线、法线、颜色以及uv等。
- [理论知识](#理论知识)
  - [Culling](#culling)
    - [渲染剔除](#渲染剔除)
      - [Pre-Z Pass](#pre-z-pass)
    - [可自行拓展的高级剔除方案](#可自行拓展的高级剔除方案)
  - [Simplization](#simplization)
    - [那些内容需要简化](#那些内容需要简化)
    - [Unity 工程中的简化方案](#unity-工程中的简化方案)
    - [可自行拓展的高级简化方案](#可自行拓展的高级简化方案)
  - [Batching](#batching)
    - [哪些内容需要 Batching](#哪些内容需要-batching)
    - [资源 Batching](#资源-batching)
      - [Mesh](#mesh)
      - [Texture](#texture)
      - [Shader 与材质](#shader-与材质)
    - [Draw Call Batching](#draw-call-batching)
      - [Static Batching](#static-batching)
      - [Dynamic Batching](#dynamic-batching)

# 理论知识

Culling Simplization Batching

Culling 先剔除

Simplization 再分类简化

Batching 最后合批运载

Culling 剔除、Simplization 简化、Batching 合批，三者的最终目的均为优化渲染提前期，使得渲染下游能够持续得获取数据并处理。

细分起来，Culling 为去除不需要渲染的信息，Simplization 为对待渲染的内容根据类型分类，Batching 为对数据路径类似的信息进行打包转发。

这些都发生在生产之前，例如进入 GPU 管线之前。一般这些工作由 CPU 负责。也有将 CPU 端工作放到 gpu 流水线上运行的。

## Culling

剔除包括狭义的渲染剔除、广义的资源剔除和代码剔除。

### 渲染剔除

![Culling 其中最后一个为场景剔除而非灯光剔除](image-20.png)

#### Pre-Z Pass

利用第一遍 pass，以当前画面最小深度绘制一张深度图并把它写入到 zBuffer 中，同时关闭颜色输出，然后在第二遍 pass 真正绘制场景像素时，只绘制深度值与 zBuffer 中对应像素值深度值相等的像素。相当于按场景最小深度值绘制了一遍场景外壳。这样可以减少像素着色器执行次数，减轻 GPU 片源着色器的负担，以提高渲染效率

现代 GPU 设计都会尽量在光栅化后，进入片元着色器前进行深度测试，并删除看不见的像素，这个技术在大部分 GPU 上都可以从硬件上支持了，也就是我们常说的 early-z 技术。那么 unity 为什么还需要通过 depth priming 或者 pre-z pass 来手动实现像素深度剔除呢？

这是由于以下几种情况会造成硬件支持的 early-z 功能失效
1. 开启了 alpha 测试
2. 手动调用了 clip 或 DIA 指令丢弃片源
3. 关闭了深度测试或者手动修改 GPU 差值得到的深度

简单来说就是 GPU early-z 已经做好了深度剔除测试但你后面又修改了深度或者直接将片源给 clip 或 Discard 掉了，这当然会造成 early-z 的失效，这种情况只能依靠我们手动保障如何按深度剔除看不见的像素以阻止他们进入片源着色器了。

如何使用：  
![Depth Priming](image-21.png)

自动开启选项，它是在你的渲染对象做 depth only pass 时自动开启 depth priming 功能，不管你的 depth only pass 是不是为了做深度剔除检测。

在不开启 depth priming 功能时，我们用 frame debugger 抓一针，默认渲染对象的 zTest 选项是 lessEqual 的比较方法。  
在开启 depth priming 功能时，会多一个 depth prepass 的流程，这个流程下面的渲染对象的 zWrite 选项是开启的同时 ColorMask 是零。说明这个 pass 只做深度缓冲的写入而不做颜色的输出。而在真正渲染对象的 pass 中，之前渲染对象的 zTest 选项已经变成 Equal 的方法，这就是只有深度相等的像素才会进入到片源着色器中。

使用限制：
1. 它只能在 forward 的前向渲染路径中使用，如果使用了自定义 SHADER，还需要手动在 SHADER 代码中添加 depth only pass.
2. 当你的游戏场景不复杂，overdraw 不是造成 GPU 效率的瓶颈时，深度启动功能没有多大意义，甚至可能造成负优化。
3. 第三是在手机和移动设备上 depth priming 功能与 MSAA 同时开启会带来额外的开销，我们需要对比和 overdraw 带来的开销哪个大，如果前者比后者的开销还大，那么开启 depth priming 功能也是没有意义的。
4. 还要对比开启 depth priming 功能后 DrawCall 或其他图形 API 的调用开销是否比 OverDraw 带来的开销还要大，因为多了 depth prepass 后，drawCall 的调用次数一定会增多，如果前者开销大的话，那么也不建议开启 depth priming 功能

总之我们需要对比开启 depth priming 能前后的渲染效率来判断此功能是否带来的是正优化。

### 可自行拓展的高级剔除方案

场景数据结构：Octree、BSP Tree、Portal、Voxelization；

GPU Culling：Hi-Z Pass、Temporal Reprojection Culling、Cluster、Tile-based Visible Buffer。

## Simplization
### 那些内容需要简化

较重的游戏资源，比如运行时占用内存较高或处理耗时较长的资源 和 运行低效且不合适的功能

### Unity 工程中的简化方案

- Quality Settings 中有若干配置项，可以根据目标平台进行选用；
- 使用烘焙光照简化实时光照；
- 使用 BoudingBox 或组合碰撞体来代替 Mesh 碰撞体；
- 使用 Local Volume 代替 Global Volume；
- 使用 Raycast 代替 SphereCast、CapsuleCast 等；
- 使用纹理文字代替系统文字；
- 使用 Mesh LOD、Shader LOD、HLOD 等 LOD 方案；
- 在 Camera 中 Override 一些 URP 管线中的通用设置；
- OnDemandRendering 配置；

### 可自行拓展的高级简化方案

- 场景数据结构简化：retracing 场景数据结构化来简化。 sdf，体素化，点云。
- 第三方 LOD 方案与插件：自动化、实时 LOD
- Mesh Impostor：虚假替代体简化（Amplify Impostors）
- AnimationLOD：视距降低远处动画频率
- 骨骼 LOD：远处骨骼较少的 lod
- 2D 寻路代替 Navigation Mesh
- 拓展类似 OnDemand 接口。

## Batching

### 哪些内容需要 Batching

资源 Batching：   
分为 Mesh、Texture、Shader 参数、材质属性；资源 Batching 是做其他渲染合批优化的前提。

Draw Call Batching：   
分为 Static Batching、Dynamic Batching；通过将多个 Draw Call 合批成一个较大的 Draw Call，从而减少 CPU 到 GPU 之间的通信开销和渲染管线中的状态切换次数。

Set Pass Call Batching：  
仅有 SRP Batching；将具有相同渲染状态和材质属性的多个 Draw Call 合批成一个大的 Draw Call，并在 GPU 上以一次性的方式执行，而不是逐个绘制调用。

GPU Instancing：  
分为直接渲染、间接渲染、程序化间接渲染；在 GPU 中一次性传递多个相同网格的实例数据，然后在 GPU 内部进行并行处理和渲染，同样起到减少 Draw Call 的目的从而优化性能。

上述各类 Batching 方案，在实践效果意义上的优先级一般为：资源 Batching > SRP Batching = Static Batching > GPUInstancing > Dynamic Batching。

### 资源 Batching

#### Mesh

使用 Mesh.ConbineMesh 合并相邻的网格对象。（非运行时）   
优点在于，能够使用对整体网格的单次 Draw Call，来代替零散网格的多次 Draw Call。  
缺点在于，可能会带来额外的内存开销，同时 Occulusion Culling 会受到影响，在某些情况下可能会导致剔除不够精确从而带来的 Overdraw。

对于 SkinnedMeshRenderer，其在动态合并或拆分 Mesh 时，可能需要根据需求考虑 Bone、UV 和 Texture 的合并。

#### Texture

Texture 的组合合并思路，有 AtlasTexture 和 TextureArray 两种类型。

Atlas Texture 是将多个小纹理合并成一个大纹理的技术，在使用时通过 UV 坐标来指定每个小纹理的位置。这样做可以减少渲染时的纹理切换次数，从而提高性能。

Texture Array 是将多个纹理作为一个纹理数组存储在 GPU 内存中的技术。这样做可以在单个渲染调用中同时使用多个纹理，从而减少 CPU 到 GPU 的通信开销和渲染状态切换次数。通常用于同时渲染具有相似外观但不同纹理的物体，例如一组树木或草地。

#### Shader 与材质

尽量不要为了微小的属性差异而生成与配置大量几乎重复的材质球，而是可以考虑通过代码做参数覆盖。

Build In 管线下，使用 Material Property Block (Renderer.SetPropertyBlock)。

SRP 管线下，使用 Const Buffer (Material.SetFloat、Material.SetConstantBuffer 等）。

### Draw Call Batching

#### Static Batching

将静态物体合并为一个大网格，从而以更快的速度渲染它们。  

Static Batching 不一定减少 DrawCall，但是会让 CPU 在“设置渲染状态-提交 Draw Call”上更高效。

限制条件为：一个静态批处理中，顶点数量上限为 64000。同时类似 ConbineMesh，可能存在额外的内存开销与 Occulusion Culling 影响。

具体配置方式为：在 ProjectSettings-Player 中勾选“Static Batching”项，同时在编辑器中对于需要实现 Static Batching 的 GameObject，在其 Static 中勾选“Batching Static”项。对于 Runtime 动态生成的对象，可以用 StaticBatchingUtility.Combine 方法在运行时动态合批。

#### Dynamic Batching
---
layout: post
title:  "0 待整理知识"
date:   2024-03-21
categories: C++
---

本文是一些未分类到具体哪一期的知识。  

[使用cpp库操作文件](#使用cpp库操作文件)  
[size和count命名含义](#size和count命名含义)  
[const和mutable](#const和mutable)  

## 使用cpp库操作文件
fstream操作文件。ifstream读取文件。

sstream存储信息流。getline逐行获取。stringstream存储文件内容。

```Cpp
#include <iostream>
#include <fstream>
#include <sstream>

#define Log(x) std::cout << x << std::endl;

int main()
{
	std::ifstream stream("src/Something.txt");
	std::string line;
	std::stringstream ss;

	while (getline(stream, line))
	{
		ss << line << "\n";
	}

	Log(ss.str());
	std::cin.get();
}
```

## size和count命名含义
size 意味着 字节数  
count 意味着 数量统计

## const和mutable
const是一个假的关键字，它是程序员的一种承诺，承诺之后不会对它修饰的东西进行更改，虽然我们可以绕过这个承诺。  
mutable是在const基础上突破它的限制。  
#### const修饰普通类型
代表着这个类型的数据不允许被更改，是个常量。
#### const修饰指针
```Cpp
int a = 1, b = 2;
// 不允许这个指针指向的内存中的东西更改，但是可以改变指针本身的指向
const int* ptr0 = &a;	
*ptr0 = b;		// *ptr不允许更改
ptr0 = &b;		// ptr允许更改

// const后置则相反
int* const ptr1 = &a;	
*ptr1 = b;		// *ptr允许更改
ptr1 = &b;		// ptr不允许更改

// 两者更是可以配合使用
const int* const ptr2 = &a;	
*ptr2 = b;		// *ptr不允许更改
ptr2 = &b;		// ptr不允许更改

// const int * 和 int const * 是一样的，这里关键是*和const的相对位置
```
#### const修饰成员函数
操作符位于方法参数列表后，代码域前，表示这个函数不会修改类中的成员变量。
```Cpp
class Entity
{
public:
	void PrintName() const
	{
		name = "SSC";	// 不被允许
	}

private:
	const char* name = "FallShadow";
};
```
在其他函数中使用const修饰类类型，可以防止调用到有修改类风险的函数，即这个变量只能调用类中的const函数。
```Cpp
#include <iostream>

class Entity
{
public:
	void ChangeName()
	{
		name = "SSC";
	}

	void PrintName() const
	{
		std::cout << name << std::endl;
	}
private:
	const char* name = "FallShadow";
};

void PrintName(const Entity& e)
{
	e.PrintName();
	e.ChangeName();	// 不被允许
}
```

#### mutable修饰成员变量突破const限制
如果类中有一个变量，即使在const函数中也可以进行修改，就要使用mutable来进行修饰。  
符合情景的例子有：调试参数，记录函数调用次数；锁定标记，只允许同时的一个进来。  
```cpp
class Entity
{
public:
	void PrintName() const
	{
		callTime++;
		std::cout << name << std::endl;
	}
private:
	const char* name = "FallShadow";
	mutable unsigned int callTime = 0;
};

void PrintName(const Entity& e)
{
	e.PrintName();
}
```

#### mutable修饰lamda表达式
lamda不能直接访问外部的变量，所以一般使用时要传递参数。
```Cpp
int x = 8;
auto f = [=](int x)
	{
		x++;
	};
f(x);
```
但是mutable修饰的可以不用传递。其实本质上也是使用了局部变量的方法，只不过是个语法糖。
```Cpp
int x = 8;
auto f = [=]() mutable
	{
		x++;
	};
f();
```










- [constexpr](#constexpr)
	- [简介](#简介)
		- [声明编译期常量](#声明编译期常量)
		- [编译期函数计算](#编译期函数计算)
	- [与 const 区别](#与-const-区别)
	- [用法](#用法)
		- [变量](#变量)
		- [函数](#函数)
- [offsetof](#offsetof)
- [auto](#auto)
- [枚举](#枚举)
- [迭代器](#迭代器)


# constexpr 

常量表达式关键字，常量关键字

## 简介

constexpr（constant expression，常量表达式）声明的变量或函数，要求其值在编译期就能确定，让编译器能直接参与常量求值和优化。

主要作用有两个：

### 声明编译期常量

使变量/对象在编译阶段就有确定值（不是运行期才生成）。  
可用于数组大小，模板参数，枚举等所有要求常量表达式的场合。  

### 编译期函数计算

允许你写出能在编译期执行的函数（不仅仅只能对普通变量常量生效）。   
支持递归、条件、类构造等多种场景。   

## 与 const 区别

|                    | const              | constexpr                  |
| ------------------ | ------------------ | -------------------------- |
| 语义               | 修饰只读（不能改） | 修饰常量表达式（编译时值） |
| 初始化             | 可以运行时赋值     | 必须编译期可赋值           |
| 可否用于常量表达式 | 有时可以           | 一定可以                   |
| 表达式限制         | 少                 | 更严格                     |
| 函数修饰           | 不能修饰           | 可修饰函数                 |

## 用法

### 变量

对于变量，constexpr 表示该变量的值在编译时就可以确定。

```Cpp

constexpr int N = 10;     // 编译时常量  

```

应用场景：  
使用 constexpr 可以优化代码，因为它允许在编译时进行计算，减少运行时开销。  
例如，用于数组大小、模板参数、常量表达式等。  

### 函数

当我们使用 constexpr 修饰函数时，它表明该函数可以在编译时求值，而不仅仅在运行时。

constexpr 函数应该满足以下条件：
- 函数体内只能包含一条 return 语句（C++11）或多条语句（C++14 及更高版本）。
- 函数只能引用常量全局变量。
- 函数只能调用其他 constexpr 函数，而不能调用普通函数。
- 函数不能是 void 类型。

```Cpp

constexpr int add(int a, int b) 
{
    return a + b;
}

```

# offsetof

```cpp
struct Vertex
{
	float Position[2];
	float Color[4];
	float TexCoords[2];
	float TexID;
};
offsetof(Vertex, Position);
```
用来很方便地探知变量所在的偏移位置，比起手动计算，使用 offsetof，即使有改动，也不需要变动函数。

# auto

auto 能帮助自动推断类型。然而绝大多数情况都用不到的。
虽然如果在调用函数的返回值接收上使用 auto 可以避免函数的改变影响到调用方，但实际上我们还是想知道具体类型的，不然可能会有很多错误的操作。
不过在你的变量很长的情况下，还是可以用 auto 来简化代码，不过我更倾向于仅仅在临时使用是这样做，比如迭代器的类型很长，而且我知道，迭代过后我就不会再用到那个变量，这时候我会用 auto，不然就算是函数返回类型非常长，我也会用 using 或者 typedef 来简化代码，而不是 auto。
还有一种情况是，在复杂的代码环境下，有可能是模版或者其他，我们甚至无法知道具体类型而不得不使用 auto 这个时候要注意了，你有可能需要审视你的整个代码了，因为它发出了太复杂的警告！

# 枚举

C++98 的 enum 是 "非域内枚举" 存在命名空间污染

```Cpp
// yellow, green, blue are in same scope as Color 
enum Color { yellow, green, blue};  

// error! yellow already declared in this scope 
auto yellow = false;　
```

C++11 的 enum class 是 "域内枚举"

# 迭代器

作用是用来遍历容器，而且是通用的遍历容器元素的方式，无论容器是基于什么数据结构实现的，尽管不同的数据结构，遍历元素的方式不一样，但是用迭代器遍历不同容器的代码是完全一样的。

迭代器一般实现为容器的嵌套类型，在容器内部提供具体的实现。但是容器不同，底层元素遍历的方式也不同，那么为什么说迭代器遍历所有容器的方式是一样的呢？那是因为迭代器提供了常用的 operator!=，operator++，operator *等运算符的重载函数，把迭代容器的细节全部隐藏在这些通用的运算符重载函数里面，因此用户侧表现出来的就是，迭代器遍历所有容器的方式都是一样的，其实底层都是不一样的风景^^！


# 自增运算 ++

![alt text](U97VGAH(7M2N68EM@C$SR)U.png)

关键点在于“后缀自增”的求值规则：g_current_pos++ 有两个动作，且顺序是“先产生旧值参与本次表达式，再在表达式求值完成后对变量做自增的副作用”。

把 *g_current_pos++ 拆开成更精确的语义步骤是：

t = g_current_pos // 取“旧指针值”，用于本次表达式
计划一个副作用：g_current_pos 自增一个元素（地址加 sizeof(uint)），副作用发生在本次表达式求值完成之后
对旧指针值解引用：*t = id // 把 id 写到 t 指向的单元（也就是 cell0）
表达式完成后，执行副作用：g_current_pos = g_current_pos + 1（现在指向 cell1）
因此不是“先移动再赋值”，而是“旧值参与、后移动”。这正是后缀 ++ 的含义：参与本次运算的是自增前的值；自增这个动作作为副作用在表达式求值之后发生。

对比一下：

*g_current_pos++ = id

使用旧地址写 cell0，然后指针移动到 cell1
*++g_current_pos = id

前缀自增：先把指针增到 cell1，再把 id 写到 cell1
(*g_current_pos)++ // 不同语义

给 cell0 里的数值本身加一，指针不动
如果仍然困惑，可以把后缀 ++ 想成“返回旧值，并预约一次自增在式子结束时执行”。
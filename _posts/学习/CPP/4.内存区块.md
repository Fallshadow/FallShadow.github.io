- [程序内存的主要区块](#程序内存的主要区块)
  - [代码区（Text Segment）](#代码区 text-segment)
  - [全局/静态区（Data Segment，包括 Data \& BSS）](#全局静态区 data-segment 包括-data--bss)
    - [已初始化数据区（Data Segment）](#已初始化数据区 data-segment)
    - [未初始化数据区（BSS Segment）](#未初始化数据区 bss-segment)
  - [静态只读数据段 （read-only data segment）rodata](#静态只读数据段-read-only-data-segmentrodata)
  - [栈区（Stack Segment）](#栈区 stack-segment)
  - [堆区（Heap Segment）](#堆区 heap-segment)
  - [常量区（Literal/Const Segment）](#常量区 literalconst-segment)
  - [总结](#总结)
- [constexpr 内存特殊性](#constexpr-内存特殊性)
  - [特殊情况：取地址](#特殊情况取地址)
  - [总结](#总结-1)

# 程序内存的主要区块

## 代码区（Text Segment）

存放程序的机器指令（即可执行代码）。   
内容通常是只读的，防止代码被篡改。   
所有的函数都放在这里，不管是否静态。  

## 全局/静态区（Data Segment，包括 Data & BSS）

存放全局变量和静态变量（包括局部和类内静态成员），生命周期是整个程序运行期。

这些变量既不在栈上也不在堆上。

### 已初始化数据区（Data Segment）

已赋初值的全局/静态变量（如 int a = 1; static int b = 2;）

### 未初始化数据区（BSS Segment）

未赋初值的全局/静态变量（如 int x; static int y;），启动时自动归零

## 静态只读数据段 （read-only data segment）rodata

rodata 是静态存储的一种“只读专用分区”。  
用于存放：虚函数表、只读字符串、全局 const 变量（视编译器）等。  
物理上它和 data/bss 并列，但保护更严格（防止被恶意或无意修改）。  
在现代二进制格式（如 ELF）/操作系统内存保护下，只读属性提升代码和常量的安全性和可靠性。  

## 栈区（Stack Segment）

存放局部变量、函数参数、返回地址等。  
编译器自动分配和释放。  
会随函数调用入栈/出栈自动管理。  

## 堆区（Heap Segment）

通过 new、malloc 等手动分配、delete、free 手动释放。  
用于动态分配内存，程序员负责管理（易发生内存泄漏）。  
适用于运行时才知道需要多少内存，或想让多函数/对象共享数据时。

## 常量区（Literal/Const Segment）

存放常量字符串、const 只读数据等。  
例如 "hello"、const int x = 5;（可能被编译器优化进代码区或数据区）

## 总结

| 内存区 | 分配/回收方式        | 代表内容                  | 生命周期         |
| ------ | -------------------- | ------------------------- | ---------------- |
| 代码区 | 编译链接器决定       | 可执行机器代码            | 程序整个运行期   |
| 数据区 | 编译链接器决定       | 静态/全局变量（已初始化） | 程序整个运行期   |
| BSS 区 | 编译链接器决定       | 静态/全局变量（未初始化） | 程序整个运行期   |
| 常量区 | 编译链接器或编译优化 | 字面量常量、const 数据    | 程序整个运行期   |
| 栈区   | 自动管理             | 局部变量、函数参数        | 函数调用生存期   |
| 堆区   | 程序员手动管理       | 动态分配对象/数组         | 直到 free/delete |

# constexpr 内存特殊性

constexpr 修饰的变量/成员，要求编译期确定值，编译器倾向于直接用字面量替代（常量折叠/内联）。  
通常不会在内存中真的分配“变量空间”，而是作为常量值，直接嵌入到最终的机器代码中。 

```Cpp

class Bar {  
public:  
    static constexpr int SZ = 100;  
};  
int arr[Bar::SZ]; // 等价于 int arr[100];  

```

这里 SZ 直接被编译器当作整数常量处理。

## 特殊情况：取地址

```Cpp

const int* p = &Bar::SZ;

```

有的编译器会为 SZ 分配一份实际存储空间，此时通常会放在静态数据区（和 static const 一样的地方）。  
但如果你没有取地址，绝大部分编译器都会直接优化掉，不分配任何存储空间。  

## 总结

| 类型                   | 是否总在静态数据区 | 说明                     |
| ---------------------- | ------------------ | ------------------------ |
| static const int       | 通常是（需要存储） | 除优化外一般分配空间     |
| static constexpr int   | 通常否（内联优化） | 仅取地址时有静态分区分配 |
| constexpr（类外/全局） | 通常否（内联优化） | 仅取地址时才可能有       |

“constexpr 一般不分配存储空间，不占静态数据区；只在必须要有内存地址时（如取地址）才可能在静态数据区分配存储。”
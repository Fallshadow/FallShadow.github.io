- [堆](#堆)
- [栈](#栈)
- [对比](#对比)
- [内存速度](#内存速度)
- [关键字](#关键字)
  - [new](#new)
  - [placement new](#placement-new)
    - [注意事项](#注意事项)
    - [应用举例：对象池](#应用举例对象池)
  - [malloc](#malloc)

# 堆

一旦你在堆上分配一个对象，就创建了一个一直存在在那里的对象。如果你的类很大或者类的生命周期跨域，那就在堆上弄吧！

```Cpp

int main()
{

	Player* p = new Player(27, 10, "FallShadow");
	Log(p->GetName());
	std::cin.get();
	delete p;
}

```

由操作系统统一管理，供进程动态分配使用。  
位于全局/静态数据区和栈区之间，占用较大（受操作系统限制）。  

# 栈

栈通常是一个预定义大小的内存区域，通常为 2M 字节左右。（如 2 MB~8 MB)   
速度很快，几乎是一个 cpu 指令，而且一个作用域死亡时，delete 也很快，几乎是一个 cpu 指令，指针就回到了之前的位置。栈是向后分配的，即先分配的地址高。  
栈上的变量一个挨着一个在缓存线上（debug 下，变量之间会被插入守卫防止溢出等问题）  
生命周期由声明的地方的作用域决定，一但超过作用域，内存就会被释放掉。 

FILO（先进后出） 每次函数调用会为其分配一个栈帧（stack frame）。局部变量、参数、返回地址都放在栈上，函数退出后自动回收。

```Cpp

#include <iostream>
#define Log(x) std::cout << x << std::endl;
using String = std::string;

class Player
{
public:
	Player() : age(0), speed(0), name("Unknown") {}
	Player(int pAge, int pSpeed, String pName) : age(pAge), speed(pSpeed), name(pName) {}

	String GetName() const
	{
		return name;
	}

private:
	int age;
	int speed;
	String name;
};

int main()
{
	Player* ptrPlayer;
	{
		Player p(27,10,"FallShadow");
		ptrPlayer = &p;
		Log(ptrPlayer->GetName());
	}
	Log(ptrPlayer->GetName());
	std::cin.get();
}

```

经常犯的一个错误是，在函数里创建栈变量，然后 return 其指针，这完全错误，函数执行后，指针所指的变量也被销毁了。

# 对比

|          | 栈（Stack）                    | 堆（Heap）                          |
| -------- | ------------------------------ | ----------------------------------- |
| 管理方式 | 操作系统自动分配和释放（FIFO） | 程序员手动分配和释放                |
| 分配方式 | 静态分配、自动分配             | 动态分配                            |
| 空间有限 | 较小（几兆到几十兆）           | 较大，受限于物理/虚拟内存           |
| 分配速度 | 非常快（指针移动，原子操作）   | 较慢（涉及申请/释放算法）           |
| 生命周期 | 随函数创建和销毁自动管理       | 手动控制，new/malloc 和 delete/free |
| 溢出风险 | 容易栈溢出（Stack Overflow）   | 溢出一般会导致内存泄漏或碎片        |
| 典型用途 | 局部变量、函数调用、返回地址等 | 动态对象/数组、大对象               |

只要能放到栈上的变量就别放堆上，堆不是慢在分配自身，而是慢在要新申请物理内存、管理碎片和手动释放的成本，预分配和管理好的大块堆可以缓解大部分性能问题，但仍没有栈来的简单高效。

# 内存速度

程序的所有可用内存最终都是同一个物理内存（RAM），只是虚拟地址空间里分了堆、栈、代码段、全局数据/bss/rodata 等区域而已。

所以其实在堆还是栈上分配其实速度都一样的。造成性能差异的主要原因有二：

- 堆里的分配要看空闲块表、可能有碎片、合并等管理动作，而栈本身是简单指针增减（push/pop），非常快
- 一旦程序用光了现有堆，真正要向操作系统 “要新内存” 时（brk, sbrk, mmap 等），性能最慢，因为牵涉到内核管理、页表变动等。

这里的第二点，可以极端假设，一次申请 4GB 堆内存（指完全够用的内存），之后堆分配速度就基本上和栈一致。

# 关键字

## new

new 代表着在堆上分配内存，以一种策略来寻找空闲内存，并将指定类型数据初始化到那片内存。

new 和 delete 成对出现

```C++

int* list = new int[50];
delete[] list;

```

- 分配原生内存

new 首先会调用全局或自定义的 operator new（实际上它是个函数）。本质就是向堆申请一定字节的原始内存（类似于 malloc）。

    分配流程：  
    - 检查当前堆空间的空闲列表/管理结构，看是否有足够的一块。
    - 如果无合适空闲块，可能向操作系统请求更多堆（如调用 brk/sbrk/mmap 等）。
    - 标记这块被占用，调整管理结构（如空闲链表剔除这块）。

- 构造对象

operator new 返回的只是未初始化的原始内存指针，并不会构造对象。  
接下来，new 会自动调用对象的构造函数，在这段内存上 “原地” 构造对应类型的对象，类似于：

```Cpp

T* obj = new (ptr) T(constructor_args);   // placement new  

```

这一步会初始化成员变量，以及如果有父类，父类的构造函数也被调用。  
如果是数组，还要一连串调用每个元素的构造函数。  

- 返回对象指针

new 返回最终指向该对象（或对象数组）的指针。  
程序员拿到这个指针，可以直接使用，生命周期由你控制，需要手动 delete（或 delete[]）释放。

- 失败处理

如果堆内存不够，operator new 可能抛出 std::bad_alloc 异常（标准 C++），或者返回 nullptr（用 nothrow new）。  
这体现了“堆分配不是 100%成功”的不确定性，极端情况下你要处理失败。

- 可选步骤：对齐和 hook

一些类型需要特殊对齐，operator new 还会考虑内存对齐要求。  
你也可以重载全局/类内的 operator new 实现“内存池”、“统计调试”等特殊分配器功能。

## placement new

new 是一个操作符，这意味着我们可以重载来重定义它的行为。  
new 还有一个行为是，将数据初始化到指定位置内存，这个行为就不会去寻找空内存了，因为要存放的内存是我们手动指定的。

placement new 是 C++ 语法中的一种特殊形式，允许你在已分配好的内存上构造对象（即“指定放置”）。  
它的语法是

```Cpp
new (address) Type(args...);  
```

```C++

int main()
{
	int* list = new int[50];
	Player* p = new(list) Player(27, 10, "FallShadow");

	std::cin.get();

	delete p;
	delete[] list;
}

```

| 普通 new                          | placement new                        |
| --------------------------------- | ------------------------------------ |
| `T* p = new T(args);`             | `T* p = new(addr) T(args);`          |
| 1. 自动分配堆空间（operator new） | 1. 不分配内存（不调用 operator new） |
| 2. 调用构造函数                   | 2. 在给定地址调用构造函数            |
| 3. 返回对象指针，需 delete        | 3. 不需 delete，只析构，不释放内存   |

### 注意事项

- placement new 不分配内存，只调用构造函数！你要自己保证内存足够而且已对齐。

- 无需 delete： placement new 构造的对象不能用 delete 释放，只需显式调用析构。

- 内存泄漏风险低，复用风险高。你必须保证析构函数被调用，不能遗忘，否则资源得不到释放。

- 常用场合：STL 容器、内存池、对象池都大量用 placement new

### 应用举例：对象池

```Cpp
char pool[10 * sizeof(Foo)];  
for (int i = 0; i < 10; ++i) {  
    Foo* obj = new(pool + i * sizeof(Foo)) Foo(i);  
    // ... 常规操作  
    obj->~Foo();  // 手动析构  
}  
```

## malloc

| 特点             | `new`                       | `malloc`                   |
| ---------------- | --------------------------- | -------------------------- |
| **归属语言**     | C++                         | C                          |
| **返回类型**     | 指定类型指针（如`int*`）    | `void*`，需强制类型转换    |
| **分配内存类型** | 堆（heap）                  | 堆（heap）                 |
| **调用构造函数** | 会调用对象构造函数          | 不调用任何构造函数         |
| **初始化**       | 可以直接初始化对象/基本类型 | 不会初始化，内存内容不确定 |
| **释放方式**     | `delete`/`delete[]`         | `free()`                   |
| **失败时行为**   | 抛出 `std::bad_alloc` 异常  | 返回 `nullptr`             |
- [计算机内存](#计算机内存)
  - [32 位 cpu 的内存](#32-位-cpu-的内存)
  - [64 位 cpu 的内存](#64-位-cpu-的内存)
- [程序内存的主要区块](#程序内存的主要区块)
  - [代码区（Text/Code Segment）](#代码区textcode-segment)
  - [静态只读数据段/常量区 （read-only data segment）.rodata](#静态只读数据段常量区-read-only-data-segmentrodata)
  - [全局/静态区（Data Segment，包括 Data \& BSS）](#全局静态区data-segment包括-data--bss)
    - [已初始化数据区（Data Segment）.data](#已初始化数据区data-segmentdata)
    - [未初始化数据区（BSS Segment）.bss](#未初始化数据区bss-segmentbss)
  - [堆区（Heap Segment）](#堆区heap-segment)
  - [内存映射区 (Memory Mapping Segment)](#内存映射区-memory-mapping-segment)
  - [栈区（Stack Segment）](#栈区stack-segment)
    - [栈溢出](#栈溢出)
    - [环境变量与参数 (Env \& Args)](#环境变量与参数-env--args)
  - [内核空间](#内核空间)
  - [总结](#总结)
- [constexpr 内存特殊性](#constexpr-内存特殊性)
  - [特殊情况：取地址](#特殊情况取地址)
  - [总结](#总结-1)

# 计算机内存

## 32 位 cpu 的内存

我们需要理解 32 位 CPU 的寻址能力。CPU 通过地址总线来访问内存，每一个地址对应一个内存单元（通常是 1 个字节）。地址总线的位数决定了 CPU 可以访问的最大内存地址数量。

32 位 CPU 的地址总线通常是 32 位（或更少，但最多 32 位）。因此，CPU 可以产生的地址数量为 2 的 32 次方个。

每个地址对应一个字节（Byte）的内存空间，所以：最大内存地址数量 = 2^32

因此，最大可寻址内存为：2^32 Bytes = 4,294,967,296 Bytes

换算成GB（通常 1GB = 1024^3 = 1,073,741,824 Bytes）：4,294,967,296 / 1,073,741,824 = 4 GB

所以，从理论上讲，32 位 CPU 最大支持 4 GB 内存。

## 64 位 cpu 的内存

理论上：64 位寻址空间上限是 2 的 64 次方字节 ≈ 16 EB（超级夸张的数字）。

实际上：
- CPU 设计者不会真的把 64 位都用满（比如 x86_64 现在常见的是 48 位或 52 位虚拟地址）。
- 主板、芯片组、BIOS/UEFI、操作系统都会各自限制最大支持内存。
- 你自己物理上只插了多少条内存条，也会限制。

# 程序内存的主要区块

从低地址到高地址，程序内存依次是：代码区、已初始化全局/静态区、未初始化全局/静态区、静态只读数据区、栈区、堆区

## 代码区（Text/Code Segment）

存放内容：CPU 执行的机器指令，也就是编译之后的程序二进制代码。

- 只读：内容通常是只读的，防止代码被篡改。  
- 共享：多个相同的程序共享一份代码区，节省内存。
- 大小固定：在程序加载时就已经确定。所有的函数都放在这里，不管是否静态。  

## 静态只读数据段/常量区 （read-only data segment）.rodata

rodata 是静态存储的一种 “只读专用分区”。  

用于存放：虚函数表、只读字符串、全局 const 变量（视编译器）等。  

物理上它和 data/bss 并列，但保护更严格（防止被恶意或无意修改）。  

在现代二进制格式（如 ELF）/操作系统内存保护下，只读属性提升代码和常量的安全性和可靠性。  

注意 const 修饰的局部变量不在常量区而在栈区。

## 全局/静态区（Data Segment，包括 Data & BSS）

存放全局变量和静态变量（包括局部和类内静态成员），生命周期是整个程序运行期。

静态区的核心特点：生命周期贯穿整个程序。无论静态变量是全局的还是函数内部的，它们都只被初始化一次，函数多次调用之间，变量不会被自动重置，能保留上一次调用后留下的值。（值是否变化取决于程序是否修改它。）

### 已初始化数据区（Data Segment）.data

已赋初值的全局/静态变量（如 int a = 1; static int b = 2;）

这些变量既占用物理内存（运行时），也占用硬盘空间（可执行文件）。

### 未初始化数据区（BSS Segment）.bss

未赋初值的全局/静态变量（如 int x; static int y;），启动时自动归零（对于指针是 NULL ）

这些变量只占用物理内存（运行时才分配），不占用硬盘空间。这样可以减少对空间的浪费，比如定义了一个int array[10000]，如果在可执行文件中存储 10000 个 0 是对空间的巨大浪费，实际上只需要记录一个大小为 40KB 的占位符即可。

## 堆区（Heap Segment）

- 向上生长：堆的内存地址是从低向高增长的，当我们 new/malloc 时，堆顶指针会向高地址移动。

- 手动管理：在堆上分配的内存，必须由程序员手动释放（delete/free）。优点是灵活性极高，生命周期由程序员掌控。缺点是非常容易产生内存泄露或内存碎片。正是因为手动管理堆内存很容易出错，C++11 及以后会使用智能指针来自动管理堆内存。

- 空间大

```Cpp
void func() { int* p = new int[100]; delete[] p; // 内存释放 }
```

如上所示，new int[100] 是真正分配的整数数组对象，存放在堆区；p 是指针对象本身（ 8 字节）存放在栈区（局部变量），栈上的指针 p 指向堆上的内存地址。

## 内存映射区 (Memory Mapping Segment) 

内存映射区是堆和栈中间的一块“缓冲区”。

- 动态链接库：程序运行依赖的.so就是加载在这里的。
- 文件映射：通过mmp系统调用，将文件直接映射到内存中。
- 大块内存申请：当我们在代码中申请很小的内存时，分配器是在堆上分配内存的，而申请大内存时，malloc会直接去内存映射区，通过mmap系统调用申请一块独立的内存。
- 物理隔离：内存映射区位于堆和栈之间，利用了虚拟地址空间中间巨大的未分配区域，避免了堆和栈过早得冲突。

## 栈区（Stack Segment）

栈是函数执行时的主要活动场所。栈被组织成一个个栈帧，每个被调用的函数都有自己的栈帧，里边存放局部变量、函数参数和返回地址。

- 向下生长：栈的内存地址时从高向低扩展的。这是因为堆从低处向上长，栈从高处向下长，两者在中间的空闲区域相向而行，最大程度上利用了虚拟地址空间。
- 自动管理：栈上的内存分配和释放完全由编译器插入的指令自动完成。当函数被调用时，栈帧入栈；函数返回时，栈帧出栈，内存自动回收。
- 速度快：分配内存只需要移动一下栈指针，比堆上 malloc 搜索空闲快要快得多。

### 栈溢出

栈空间通常是有限的（在Linux上默认时8MB，可以通过ulimit -s查看）。如果写一个死循环递归，或者在栈区定义了一个巨大的数组，栈指针超出边界，就会触发栈溢出，进而导致程序直接崩溃。

```Cpp

void hello() { 
  // 每次调用都会压入一个新的栈帧 
  // 没有终止条件 -> 栈溢出 
  hello(); 
} 

void world() { 
  int a = 10; //局部变量，放在栈上 
  int array[1000000]; //可能导致栈溢出 
}

```

### 环境变量与参数 (Env & Args) 

当程序启动时，操作系统会把 命令行参数 (argv) 和 环境变量 (env) 复制到用户空间的最高地址上方，它们物理上位于用户空间的最高（严格来说，并不属于栈本身），可以通过 main(int argc, char* argv[]) 来访问它们。

## 内核空间

不可读写的用户代码

内核空间存放着操作系统核心的代码和数据：内核代码、页表、进程控制块。这段代码有着最高的权限，用户态是无法访问内核空间的。如果指针不小心指向这里并试图读取，CPU的的内存管理单元 (MMU)会立刻捕获这种非法操作，操作系统会发送SIGSEGV信号，发生段错误。

这是为了防止程序破坏操作系统，用户态的代码严禁直接访问内核空间。但是可以通过系统调用请求内核帮忙，此时CPU会从用户态切换到内核态，进而区执行这些特权操作。

## 总结

| 内存区 | 分配/回收方式        | 代表内容                  | 生命周期         |
| ------ | -------------------- | ------------------------- | ---------------- |
| 代码区 | 编译链接器决定       | 可执行机器代码            | 程序整个运行期   |
| .rodata区 | 编译链接器或编译优化 | 字面量常量、const 数据    | 程序整个运行期   |
| .data区 | 编译链接器决定       | 静态/全局变量（已初始化） | 程序整个运行期   |
| .bss区 | 编译链接器决定       | 静态/全局变量（未初始化） | 程序整个运行期   |
| 栈区   | 自动管理             | 局部变量、函数参数        | 函数调用生存期   |
| 堆区   | 程序员手动管理       | 动态分配对象/数组         | 直到 free/delete |

![程序内存分布图](程序内存分布图.png)

![程序内存分布图实例](程序内存分布图实例.png)

# constexpr 内存特殊性

constexpr 修饰的变量/成员，要求编译期确定值，编译器倾向于直接用字面量替代（常量折叠/内联）。  

通常不会在内存中真的分配“变量空间”，而是作为常量值，直接嵌入到最终的机器代码中。 

```Cpp

class Bar {  
public:  
    static constexpr int SZ = 100;  
};  
int arr[Bar::SZ]; // 等价于 int arr[100];  

```

这里 SZ 直接被编译器当作整数常量处理。

## 特殊情况：取地址

```Cpp

const int* p = &Bar::SZ;

```

有的编译器会为 SZ 分配一份实际存储空间，此时通常会放在常量区（和 static const 一样的地方）。  

但如果你没有取地址，绝大部分编译器都会直接优化掉，不分配任何存储空间。  

## 总结

| 类型                   | 是否总在常量区 | 说明                     |
| ---------------------- | ------------------ | ------------------------ |
| static const int       | 通常是（需要存储） | 除优化外一般分配空间     |
| static constexpr int   | 通常否（内联优化） | 仅取地址时有静态分区分配 |
| constexpr（类外/全局） | 通常否（内联优化） | 仅取地址时才可能有       |

“constexpr 一般不分配存储空间，不占静态数据区；只在必须要有内存地址时（如取地址）才可能在静态数据区分配存储。”

